// Code generated by goa v3.1.3, DO NOT EDIT.
//
// Incident service
//
// Command:
// $ goa gen github.com/rightscale/governance/front_service/design

package incident

import (
	"context"

	incidentviews "github.com/rightscale/policy_sdk/sdk/incident/views"
	goa "goa.design/goa/v3/pkg"
	"goa.design/goa/v3/security"
)

// Service is the Incident service interface.
type Service interface {
	// Show retrieves the details of an incident.
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "extended"
	//	- "source"
	Show(context.Context, *ShowPayload) (res *Incident, view string, err error)
	// Index retrieves the list of incidents in a project.
	Index(context.Context, *IndexPayload) (res *IncidentList, err error)
	// Resolve resolves an incident by setting it to an inactive state, indicating
	// that it has been addressed.
	Resolve(context.Context, *ResolvePayload) (err error)
	// IndexEscalations retrieves the status details of all of the escalations for
	// an incident. This API method is deprecated and will no longer be updated as
	// of July 30, 2020. Please use the index_statuses method instead.
	IndexEscalations(context.Context, *IndexEscalationsPayload) (res *Escalations, err error)
	// IndexResolutions retrieves the status details of all of the resolutions for
	// an incident. This API method is deprecated and will no longer be updated as
	// of July 30, 2020. Please use the index_statuses method instead.
	IndexResolutions(context.Context, *IndexResolutionsPayload) (res *Resolutions, err error)
	// RunAction executes any action listed in available_actions on an incident. It
	// can run against all resources in an incident or only a selected amount,
	// depending on passed in options. Actions will run in parallel.
	RunAction(context.Context, *RunActionPayload) (res *RunActionResult, err error)
}

// Auther defines the authorization functions to be implemented by the service.
type Auther interface {
	// JWTAuth implements the authorization logic for the JWT security scheme.
	JWTAuth(ctx context.Context, token string, schema *security.JWTScheme) (context.Context, error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "Incident"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [6]string{"show", "index", "resolve", "index_escalations", "index_resolutions", "run_action"}

// ShowPayload is the payload type of the Incident service show method.
type ShowPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// incident_id identifies an incident by ID.
	IncidentID string
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// View used to render incident
	View *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// Incident is the result type of the Incident service show method.
type Incident struct {
	// id is the ID of the incident, must be unique in the project.
	ID string
	// incident_aggregate_id is set if incident is part of an incident aggregate.
	IncidentAggregateID *string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// href is the href of the incident.
	Href *string
	// applied_policy links to key attributes of the applied policy that initiated
	// the incident.
	AppliedPolicy *AppliedPolicy
	// summary is a summary of the incident.
	Summary *string
	// message is a description of the incident.
	Detail *string
	// violation_data_fields is a list of field names exported in violation data.
	ViolationDataFields []*DataField
	// violation data for the incident.
	ViolationData interface{}
	// The number of items in violation data.
	ViolationDataCount *uint
	// created_at is the incident creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the incident update timestamp in RFC3339 format.
	UpdatedAt *string
	// resolved_at is the incident resolution timestamp in RFC3339 format.
	ResolvedAt *string
	// resolved_by is the RightScale user that resolved the incident if it was
	// resolved manually.
	ResolvedBy *User
	// resolution_message is an optional explaination of why the incident is
	// resolved.
	ResolutionMessage *string
	// state represents the current handling status of the incident.
	State *string
	// severity defines the severity level of the incident.
	Severity *string
	// category is the type categorization of the incident.
	Category *string
	// options lists the configuration options used to parameterize the policy that
	// created the incident.
	Options []*ConfigurationOption
	// dry_run is a flag used for testing a policy, that determines whether this
	// incident should trigger escalation actions.
	DryRun *bool
	// available_actions is a list of actions that can currently be run on the
	// incident. If the incident is triggered, escalation actions will be
	// available. If the incident is in resolved, resolution actions will be
	// available. If the incident is terminated, no actions are available.
	AvailableActions []*Action
	// action_failed indicates whether any of the incident's actions failed during
	// execution.
	ActionFailed *bool
	// kind is "gov#incident".
	Kind string
	// etag is an HTTP ETag for the incident.
	Etag string
	// not_modified is a flag used internally that indicates how to encode the HTTP
	// response (i.e. 200 or 304).
	NotModified *string
}

// IndexPayload is the payload type of the Incident service index method.
type IndexPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// View used to render incidents
	View *string
	// state is a filter to only show incidents that are in this state.
	State []string
	// applied_policy_id is a filter to only show incidents that were created by a
	// certain applied policy.
	AppliedPolicyID *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// IncidentList is the result type of the Incident service index method.
type IncidentList struct {
	// count is the number of incidents in the list.
	Count *uint
	// etag is an HTTP ETag for the incident list.
	Etag string
	// items is the array of incidents.
	Items IncidentCollection
	// not_modified is a flag used internally that indicates how to encode the HTTP
	// response (i.e. 200 or 304).
	NotModified *string
	// kind is "gov#incident_list".
	Kind string
}

// ResolvePayload is the payload type of the Incident service resolve method.
type ResolvePayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// incident_id identifies an incident by ID.
	IncidentID string
	// message is an optional explanation for why the incident is being resolved.
	Message *string
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// IndexEscalationsPayload is the payload type of the Incident service
// index_escalations method.
type IndexEscalationsPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// incident_id identifies an incident by ID.
	IncidentID string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// Escalations is the result type of the Incident service index_escalations
// method.
type Escalations struct {
	// status is the status of all of the escalations.
	Status string
	// escalations is the set of escalations.
	Escalations []*Escalation
	// started_at is the time when the incident handling is started.
	StartedAt *string
	// finished_at is the time when the incident handling is finished. It exists
	// when the status is completed or failed.
	FinishedAt *string
}

// IndexResolutionsPayload is the payload type of the Incident service
// index_resolutions method.
type IndexResolutionsPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// incident_id identifies an incident by ID.
	IncidentID string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// Resolutions is the result type of the Incident service index_resolutions
// method.
type Resolutions struct {
	// status is the status of all of the resolutions.
	Status string
	// resolutions is the set of resolutions.
	Resolutions []*Resolution
	// started_at is the time when the incident handling is started.
	StartedAt *string
	// finished_at is the time when the incident handling is finished. It exists
	// when the status is completed or failed.
	FinishedAt *string
}

// RunActionPayload is the payload type of the Incident service run_action
// method.
type RunActionPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// action_id identifies an action by id.
	ActionID string
	// incident_id identifies an applied policy by ID.
	IncidentID string
	// options lists the configuration options used to parameterize the policy.
	Options []*ConfigurationOptionCreateType
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// RunActionResult is the result type of the Incident service run_action method.
type RunActionResult struct {
	Location string
}

// Project represents a RightScale project and provides some information about
// the project.
type Project struct {
	// id is the Project ID
	ID uint
	// name is the Project Name
	Name string
	// org_id is the RightScale Organization ID
	OrgID uint
	// org_name is the RightScale Organization Name
	OrgName string
}

// AppliedPolicy describes a policy that is currently applied.
type AppliedPolicy struct {
	// id identifies an applied policy by ID.
	ID string
	// policy_aggregate_id is set if applied policy is part of an policy aggregate.
	PolicyAggregateID *string
	// incident_aggregate_id is set if applied incident is part of an policy
	// aggregate.
	IncidentAggregateID *string
	// name provides a name for this specific application of the policy.
	Name string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// href is the href of the applied policy.
	Href string
	// policy_template links to key attributes of the policy template from which
	// the applied policy originated.
	PolicyTemplate *PolicyTemplate
	// published_template links to key attributes of the published template from
	// which the applied policy originated.
	PublishedTemplate *PublishedTemplate
	// description provides a human readable description for this specific
	// application of the policy.
	Description *string
	// doc_link is a HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// created_by is the RightScale user that applied the policy.
	CreatedBy *User
	// created_at is the applied policy creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the applied policy update timestamp in RFC3339 format.
	UpdatedAt *string
	// severity defines the severity level of incidents raised from this applied
	// policy.
	Severity *string
	// category is the type categorization of the applied policy.
	Category *string
	// frequency specifies the frequency with which to run policy evaluations
	Frequency *string
	// dry_run is a flag used for testing a policy so that an incident can be
	// raised without performing an action.
	DryRun *bool
	// skip_approvals means that any approval actions will be skipped and all
	// actions automatically run.
	SkipApprovals *bool
	// options lists the configuration options used to parameterize the policy.
	Options []*ConfigurationOption
	// credentials map of credentials to use. The key in the map is the credential
	// name from the PolicyTemplate and the value is the credential identifier from
	// the Credentials management page.
	Credentials map[string]string
	// status is used to identify the current status of the applied policy.
	Status *string
	// error is the error message returned if the evaluation failed. On success
	// this attribute is empty.
	Error *string
	// errored_at is the applied policy error timestamp in RFC3339 format. On
	// success this attribute is empty.
	ErroredAt *string
	// scope is whether the policy is managed at an org-wide or project level.
	Scope *string
	// kind is "gov#applied_policy".
	Kind string
}

// PolicyTemplate describes a previously uploaded policy template.
type PolicyTemplate struct {
	// id identifies a policy template by ID.
	ID string
	// name is the unique name of the policy template in the project.
	Name string
	// project_id is the ID of the project that the policy template applies to.
	ProjectID *uint
	// rs_pt_ver is the policy engine version.
	RsPtVer *uint
	// short_description is the short description of the policy template.
	ShortDescription *string
	// long_description is the long description of the policy template. The content
	// can be markdown.
	LongDescription *string
	// doc_link is an HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// default_frequency defines the interval the template will be run unless set
	// differently during application.
	DefaultFrequency *string
	// href is the href of the policy template.
	Href string
	// filename is the name of the file that was uploaded to create the policy
	// template.
	Filename *string
	// source is the policy template source code.
	Source *string
	// fingerprint is a SHA created during compilation. It is used to determine if
	// the template is outdated.
	Fingerprint string
	// category is the type categorization of the policy template.
	Category *string
	// created_by is the RightScale user that created the policy template.
	CreatedBy *User
	// created_at is the policy template creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_by is the RightScale user that updated the policy template.
	UpdatedBy *User
	// updated_at is the last update timestamp in RFC3339 format.
	UpdatedAt *string
	// permissions is a list of permissions required to run the policy.
	Permissions map[string]*Permission
	// required_roles is a list of governance roles, derived from permissions,
	// required to run the policy.
	RequiredRoles []string
	// parameters is a list of parameters required to apply the policy.
	Parameters map[string]*Parameter
	// severity defines the severity level of incidents raised from this policy
	// template.
	Severity *string
	// tenancy indicates whether this template can be run across multiple projects
	// or is restricted to a single project.
	Tenancy *string
	// credentials is a list of authorization for external APIs needed to run the
	// policy.
	Credentials map[string]*Credentials
	// kind is "gov#policy_template".
	Kind string
}

// User represents a registered RightScale user.
type User struct {
	// ID of user
	ID uint
	// email of user
	Email string
	// name of user, usually of the form 'First Last'
	Name string
}

// Permission defines a role required in RightScale to perform actions on
// resources
type Permission struct {
	// Name of a permission
	Name string `json:"name"`
	// Label is used in the UI
	Label *string `json:"label"`
	// List of resource names the permission is applied to
	Resources []string `json:"resources"`
	// List of action names the permission is applied to
	Actions []string `json:"actions"`
}

// Parameter defines a parameter given as input to a Policy
type Parameter struct {
	// Name of the parameter
	Name string `json:"name"`
	// Type of the parameter
	Type string `json:"type"`
	// Label to show in the UI
	Label string `json:"label"`
	// The index of this parameter in the list
	Index uint `json:"index"`
	// The category used to group parameters
	Category *string `json:"category"`
	// Description of the parameter
	Description *string `json:"description"`
	// The default value for the parameter
	Default interface{} `json:"default"`
	// no_echo determines whether the value of the parameter should be hidden in
	// UIs and API responses.
	NoEcho bool `json:"no_echo"`
	// List of values allowed for this parameter
	AllowedValues []interface{} `json:"allowed_values"`
	// The minimum length of a string parameter
	MinLength *uint `json:"min_length"`
	// The maximum length of a string parameter
	MaxLength *uint `json:"max_length"`
	// The minimum value of a number parmameter
	MinValue *float64 `json:"min_value"`
	// The maximum value of a number parameter
	MaxValue *float64 `json:"max_value"`
	// The regular expression pattern used to validate a string parameter
	AllowedPattern *Regexp `json:"allowed_pattern"`
	// The description used for constraints
	ConstraintDescription *string `json:"constraint_description"`
}

// Regular expression
type Regexp struct {
	// Pattern is the regular expression pattern.
	Pattern string `json:"pattern"`
	// Options are the regular expression options. Options i (case insensitve) and
	// m (match over newlines) supported.
	Options *string `json:"options"`
}

// Credentials describes a reference to an API signer in the credentials
// service in the policy language.
type Credentials struct {
	// Name in policy template source code
	Name string `json:"name"`
	// Schemes of credentials service resource supported.
	Schemes []string `json:"schemes"`
	// Label for the auth reference
	Label string `json:"label"`
	// Description of what types of permissions need to be provided by auth.
	Description *string `json:"description"`
	// Tags is an optional filter to only show credentials matching a certain tag.
	Tags []*CredentialsTag `json:"tags"`
}

type CredentialsTag struct {
	// Key is the tag key.
	Key string `json:"key"`
	// Value is the tag value.
	Value string `json:"value"`
}

// PublishedTemplate describes a previously created published template.
type PublishedTemplate struct {
	// id identifies a published template by ID.
	ID string
	// name is the unique name of the published template in the organization.
	Name string
	// org_id is the ID of the organization that the published template belongs to.
	OrgID *uint
	// project_id is the ID of the project that the published template is published
	// from.
	ProjectID *uint
	// policy_template_id is the ID of the policy template from which the published
	// template originated.
	PolicyTemplateID *string
	// policy_template_url is the full URL to the policy template from which the
	// published template originated.
	PolicyTemplateURL *string
	// policy_template_fingerprint is fingerprint of the policy template. It is
	// used to determine if the policy template that this was published from is
	// outdated.
	PolicyTemplateFingerprint *string
	// rs_pt_ver is the policy engine version.
	RsPtVer *uint
	// short_description is the short description of the published template.
	ShortDescription *string
	// long_description is the long description of the published template. The
	// content can be markdown.
	LongDescription *string
	// doc_link is a HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// default_frequency defines the interval the template will be run unless set
	// differently during application.
	DefaultFrequency *string
	// href is the self-referential href of the published template.
	Href string
	// filename is the name of the file that was uploaded to create the policy
	// template.
	Filename *string
	// source is published template source code.
	Source *string
	// fingerprint is a SHA created during compilation. It is used to determine if
	// the policy template that this was published from is outdated.
	Fingerprint string
	// category is the type categorization of the published template.
	Category *string
	// created_by is the RightScale user that created the published template.
	CreatedBy *User
	// created_at is the published template creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_by is the RightScale user that updated the published template.
	UpdatedBy *User
	// updated_at is the published template update timestamp in RFC3339 format.
	UpdatedAt *string
	// permissions is a list of permissions required to run the policy.
	Permissions map[string]*Permission
	// required_roles is a list of governance roles, derived from permissions,
	// required to run the policy.
	RequiredRoles []string
	// parameters is a list of parameters required to apply the policy.
	Parameters map[string]*Parameter
	// severity defines the severity level of incidents raised from this published
	// template.
	Severity *string
	// built_in is a flag to indicate whether the published template is a
	// "built-in" RS-supplied template.
	BuiltIn *bool
	// hidden is a flag to indicate whether the published template is hidden.
	Hidden *bool
	// hidden_by is the RightScale user that marked the published template as
	// hidden.
	HiddenBy *User
	// hidden_at is the hidden at timestamp in RFC3339 format.
	HiddenAt *string
	// tenancy indicates whether this template can be run across multiple projects
	// or is restricted to a single project.
	Tenancy *string
	// credentials is a list of authorization for external APIs needed to run the
	// policy.
	Credentials map[string]*Credentials
	// kind is "gov#published_template".
	Kind string
}

// ConfigurationOption describes a single parameter value used to configure an
// applied policy.
type ConfigurationOption struct {
	// name of option
	Name string
	// label of option
	Label string
	// type of option
	Type string
	// value of option
	Value interface{}
	// no_echo determines whether the value of the configuration option should be
	// hidden in UIs and API responses.
	NoEcho bool
}

type DataField struct {
	// key in violation_data.
	Key string
	// label is a human readable field name, if any
	Label *string
	// optional formatting or type information
	Format *string
}

// An action defines the steps taken when a policy is violated or when that
// violation is resolved.
type Action struct {
	// id is an unique identifier for the action.
	ID string
	// type is either escalation or resolution. An escalation action is applicable
	// when an incident is in a triggered state. A resolution action is applicable
	// when an incident is resolved.
	Type string
	// label is a human readable label for the action
	Label *string
	// description provides an explanation of what happens for this action.
	Description *string
	// parameters is a list of parameters required to run the action.
	Parameters map[string]*Parameter
	// whether or not this action is automatically applied to all future incidents.
	Automatic *bool
	// kind is "gov#action".
	Kind string
}

type IncidentCollection []*Incident

// Escalation holds the status of one or more actions of an escalation.
type Escalation struct {
	// status is the status of the set of escalation actions.
	Status string
	// name is the name of the escalation.
	Name string
	// actions is the list of individual actions.
	Actions []*EscalationAction
}

// EscalationAction holds the status of a single action in an escalation.
type EscalationAction struct {
	// type is the type of the action.
	Type string
	// status is the status of the action.
	Status string
	// started_at is the time when the action was started.
	StartedAt *string
	// finished_at is the time when the action was finished.
	FinishedAt *string
	// error is any error occurred when handling the action.
	Error *string
	// approval_request is the approval request resource (if the type is
	// request_approval).
	ApprovalRequest *ApprovalRequest
	// process_href is the href of a cloud workflow process. Required if the type
	// is cloud_workflow.
	ProcessHref *string
}

// ApprovalRequest describes an approval request to perform one or more actions
type ApprovalRequest struct {
	// id identifies an approval request by ID.
	ID string
	// project_id is the ID of the project where this approval request is created.
	ProjectID uint
	// href is the href of the approval request
	Href string
	// label is a short title for this approval request
	Label *string
	// description describes the details for this approval request.
	Description *string
	// subject is the subject of the approval.
	Subject *ApprovalSubject
	// created_at is the approval request creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the last update timestamp in RFC3339 format.
	UpdatedAt *string
	// parameters is a list of parameters required for approval request.
	Parameters map[string]*Parameter
	// status is the status of this approval request.
	Status *string
	// options lists the configuration options used to parameterize the approval
	// request.
	Options []*ConfigurationOption
	// approved_by is the RightScale user that approved this approval request.
	ApprovedBy *User
	// approved_at is the approval timestamp in RFC3339 format.
	ApprovedAt *string
	// denial_comment is a comment that explains the reason for denial, if relevant.
	DenialComment *string
	// denied_by is the RightScale user that denied this approval request.
	DeniedBy *User
	// denied_at is the denial timestamp in RFC3339 format.
	DeniedAt *string
	// kind is "gov#approval_request".
	Kind string
}

// ApprovalSubject is the subject of an approval.
type ApprovalSubject struct {
	// kind is the kind of subject
	Kind string
	// href is the href of the subject.
	Href string
}

// Resolution holds the status of one or more actions of a resolution.
type Resolution struct {
	// status is the status of the set of resolution actions.
	Status string
	// name is the name of the resolution.
	Name string
	// actions is the list of individual actions.
	Actions []*ResolutionAction
}

// ResolutionAction holds the status of a single action in a resolution.
type ResolutionAction struct {
	// type is the type of the action.
	Type string
	// status is the status of the action.
	Status string
	// started_at is the time when the action was started.
	StartedAt *string
	// finished_at is the time when the action was finished.
	FinishedAt *string
	// error is any error occurred when handling the action.
	Error *string
	// approval_request is the approval request resource (if the type is
	// request_approval).
	ApprovalRequest *ApprovalRequest
	// process_href is the href of a cloud workflow process. Required if the type
	// is cloud_workflow.
	ProcessHref *string
}

// ConfigurationOptionCreateType is the payload for creating a single parameter
// value used to configure an applied policy.
type ConfigurationOptionCreateType struct {
	// name of option
	Name string
	// value of option
	Value interface{}
}

type Conflict struct {
	Location string
	// message identifies the reason for the conflict
	Message string
}

// Error returns an error description.
func (e *Conflict) Error() string {
	return ""
}

// ErrorName returns "conflict".
func (e *Conflict) ErrorName() string {
	return "conflict"
}

// MakeUnauthorized builds a goa.ServiceError from an error.
func MakeUnauthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unauthorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeForbidden builds a goa.ServiceError from an error.
func MakeForbidden(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "forbidden",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadRequest builds a goa.ServiceError from an error.
func MakeBadRequest(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_request",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadGateway builds a goa.ServiceError from an error.
func MakeBadGateway(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_gateway",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInternalError builds a goa.ServiceError from an error.
func MakeInternalError(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "internal_error",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not_found",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakePreconditionFailed builds a goa.ServiceError from an error.
func MakePreconditionFailed(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "precondition_failed",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeUnprocessableEntity builds a goa.ServiceError from an error.
func MakeUnprocessableEntity(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unprocessable_entity",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewIncident initializes result type Incident from viewed result type
// Incident.
func NewIncident(vres *incidentviews.Incident) *Incident {
	var res *Incident
	switch vres.View {
	case "default", "":
		res = newIncident(vres.Projected)
	case "extended":
		res = newIncidentExtended(vres.Projected)
	case "source":
		res = newIncidentSource(vres.Projected)
	}
	return res
}

// NewViewedIncident initializes viewed result type Incident from result type
// Incident using the given view.
func NewViewedIncident(res *Incident, view string) *incidentviews.Incident {
	var vres *incidentviews.Incident
	switch view {
	case "default", "":
		p := newIncidentView(res)
		vres = &incidentviews.Incident{Projected: p, View: "default"}
	case "extended":
		p := newIncidentViewExtended(res)
		vres = &incidentviews.Incident{Projected: p, View: "extended"}
	case "source":
		p := newIncidentViewSource(res)
		vres = &incidentviews.Incident{Projected: p, View: "source"}
	}
	return vres
}

// NewIncidentList initializes result type IncidentList from viewed result type
// IncidentList.
func NewIncidentList(vres *incidentviews.IncidentList) *IncidentList {
	return newIncidentList(vres.Projected)
}

// NewViewedIncidentList initializes viewed result type IncidentList from
// result type IncidentList using the given view.
func NewViewedIncidentList(res *IncidentList, view string) *incidentviews.IncidentList {
	p := newIncidentListView(res)
	return &incidentviews.IncidentList{Projected: p, View: "default"}
}

// NewEscalations initializes result type Escalations from viewed result type
// Escalations.
func NewEscalations(vres *incidentviews.Escalations) *Escalations {
	return newEscalations(vres.Projected)
}

// NewViewedEscalations initializes viewed result type Escalations from result
// type Escalations using the given view.
func NewViewedEscalations(res *Escalations, view string) *incidentviews.Escalations {
	p := newEscalationsView(res)
	return &incidentviews.Escalations{Projected: p, View: "default"}
}

// NewResolutions initializes result type Resolutions from viewed result type
// Resolutions.
func NewResolutions(vres *incidentviews.Resolutions) *Resolutions {
	return newResolutions(vres.Projected)
}

// NewViewedResolutions initializes viewed result type Resolutions from result
// type Resolutions using the given view.
func NewViewedResolutions(res *Resolutions, view string) *incidentviews.Resolutions {
	p := newResolutionsView(res)
	return &incidentviews.Resolutions{Projected: p, View: "default"}
}

// newIncident converts projected type Incident to service type Incident.
func newIncident(vres *incidentviews.IncidentView) *Incident {
	res := &Incident{
		IncidentAggregateID: vres.IncidentAggregateID,
		Href:                vres.Href,
		Summary:             vres.Summary,
		CreatedAt:           vres.CreatedAt,
		UpdatedAt:           vres.UpdatedAt,
		ResolvedAt:          vres.ResolvedAt,
		ResolutionMessage:   vres.ResolutionMessage,
		State:               vres.State,
		ViolationDataCount:  vres.ViolationDataCount,
		Severity:            vres.Severity,
		Category:            vres.Category,
		DryRun:              vres.DryRun,
		ActionFailed:        vres.ActionFailed,
		NotModified:         vres.NotModified,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Project != nil {
		res.Project = transformIncidentviewsProjectViewToProject(vres.Project)
	}
	if vres.ResolvedBy != nil {
		res.ResolvedBy = transformIncidentviewsUserViewToUser(vres.ResolvedBy)
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = transformIncidentviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if vres.AppliedPolicy != nil {
		res.AppliedPolicy = newAppliedPolicyLink(vres.AppliedPolicy)
	}
	return res
}

// newIncidentExtended converts projected type Incident to service type
// Incident.
func newIncidentExtended(vres *incidentviews.IncidentView) *Incident {
	res := &Incident{
		IncidentAggregateID: vres.IncidentAggregateID,
		Href:                vres.Href,
		Summary:             vres.Summary,
		CreatedAt:           vres.CreatedAt,
		UpdatedAt:           vres.UpdatedAt,
		ResolvedAt:          vres.ResolvedAt,
		ResolutionMessage:   vres.ResolutionMessage,
		State:               vres.State,
		ViolationDataCount:  vres.ViolationDataCount,
		Severity:            vres.Severity,
		Category:            vres.Category,
		DryRun:              vres.DryRun,
		ActionFailed:        vres.ActionFailed,
		NotModified:         vres.NotModified,
		Detail:              vres.Detail,
		ViolationData:       vres.ViolationData,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Project != nil {
		res.Project = transformIncidentviewsProjectViewToProject(vres.Project)
	}
	if vres.ResolvedBy != nil {
		res.ResolvedBy = transformIncidentviewsUserViewToUser(vres.ResolvedBy)
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = transformIncidentviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if vres.AvailableActions != nil {
		res.AvailableActions = make([]*Action, len(vres.AvailableActions))
		for i, val := range vres.AvailableActions {
			res.AvailableActions[i] = transformIncidentviewsActionViewToAction(val)
		}
	}
	if vres.ViolationDataFields != nil {
		res.ViolationDataFields = make([]*DataField, len(vres.ViolationDataFields))
		for i, val := range vres.ViolationDataFields {
			res.ViolationDataFields[i] = transformIncidentviewsDataFieldViewToDataField(val)
		}
	}
	if vres.AppliedPolicy != nil {
		res.AppliedPolicy = newAppliedPolicyLink(vres.AppliedPolicy)
	}
	return res
}

// newIncidentSource converts projected type Incident to service type Incident.
func newIncidentSource(vres *incidentviews.IncidentView) *Incident {
	res := &Incident{
		IncidentAggregateID: vres.IncidentAggregateID,
		Href:                vres.Href,
		NotModified:         vres.NotModified,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Project != nil {
		res.Project = transformIncidentviewsProjectViewToProject(vres.Project)
	}
	if vres.AppliedPolicy != nil {
		res.AppliedPolicy = newAppliedPolicySource(vres.AppliedPolicy)
	}
	return res
}

// newIncidentView projects result type Incident to projected type IncidentView
// using the "default" view.
func newIncidentView(res *Incident) *incidentviews.IncidentView {
	vres := &incidentviews.IncidentView{
		ID:                  &res.ID,
		IncidentAggregateID: res.IncidentAggregateID,
		Href:                res.Href,
		Summary:             res.Summary,
		ViolationDataCount:  res.ViolationDataCount,
		CreatedAt:           res.CreatedAt,
		UpdatedAt:           res.UpdatedAt,
		ResolvedAt:          res.ResolvedAt,
		ResolutionMessage:   res.ResolutionMessage,
		State:               res.State,
		Severity:            res.Severity,
		Category:            res.Category,
		DryRun:              res.DryRun,
		ActionFailed:        res.ActionFailed,
		Kind:                &res.Kind,
		Etag:                &res.Etag,
		NotModified:         res.NotModified,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentviewsProjectView(res.Project)
	}
	if res.ResolvedBy != nil {
		vres.ResolvedBy = transformUserToIncidentviewsUserView(res.ResolvedBy)
	}
	if res.Options != nil {
		vres.Options = make([]*incidentviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = transformConfigurationOptionToIncidentviewsConfigurationOptionView(val)
		}
	}
	if res.AppliedPolicy != nil {
		vres.AppliedPolicy = newAppliedPolicyViewLink(res.AppliedPolicy)
	}
	return vres
}

// newIncidentViewExtended projects result type Incident to projected type
// IncidentView using the "extended" view.
func newIncidentViewExtended(res *Incident) *incidentviews.IncidentView {
	vres := &incidentviews.IncidentView{
		ID:                  &res.ID,
		IncidentAggregateID: res.IncidentAggregateID,
		Href:                res.Href,
		Summary:             res.Summary,
		Detail:              res.Detail,
		ViolationData:       res.ViolationData,
		ViolationDataCount:  res.ViolationDataCount,
		CreatedAt:           res.CreatedAt,
		UpdatedAt:           res.UpdatedAt,
		ResolvedAt:          res.ResolvedAt,
		ResolutionMessage:   res.ResolutionMessage,
		State:               res.State,
		Severity:            res.Severity,
		Category:            res.Category,
		DryRun:              res.DryRun,
		ActionFailed:        res.ActionFailed,
		Kind:                &res.Kind,
		Etag:                &res.Etag,
		NotModified:         res.NotModified,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentviewsProjectView(res.Project)
	}
	if res.ViolationDataFields != nil {
		vres.ViolationDataFields = make([]*incidentviews.DataFieldView, len(res.ViolationDataFields))
		for i, val := range res.ViolationDataFields {
			vres.ViolationDataFields[i] = transformDataFieldToIncidentviewsDataFieldView(val)
		}
	}
	if res.ResolvedBy != nil {
		vres.ResolvedBy = transformUserToIncidentviewsUserView(res.ResolvedBy)
	}
	if res.Options != nil {
		vres.Options = make([]*incidentviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = transformConfigurationOptionToIncidentviewsConfigurationOptionView(val)
		}
	}
	if res.AvailableActions != nil {
		vres.AvailableActions = make([]*incidentviews.ActionView, len(res.AvailableActions))
		for i, val := range res.AvailableActions {
			vres.AvailableActions[i] = transformActionToIncidentviewsActionView(val)
		}
	}
	if res.AppliedPolicy != nil {
		vres.AppliedPolicy = newAppliedPolicyViewLink(res.AppliedPolicy)
	}
	return vres
}

// newIncidentViewSource projects result type Incident to projected type
// IncidentView using the "source" view.
func newIncidentViewSource(res *Incident) *incidentviews.IncidentView {
	vres := &incidentviews.IncidentView{
		ID:                  &res.ID,
		IncidentAggregateID: res.IncidentAggregateID,
		Href:                res.Href,
		Kind:                &res.Kind,
		Etag:                &res.Etag,
		NotModified:         res.NotModified,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentviewsProjectView(res.Project)
	}
	if res.AppliedPolicy != nil {
		vres.AppliedPolicy = newAppliedPolicyViewSource(res.AppliedPolicy)
	}
	return vres
}

// newAppliedPolicy converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicy(vres *incidentviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		PolicyAggregateID:   vres.PolicyAggregateID,
		IncidentAggregateID: vres.IncidentAggregateID,
		Description:         vres.Description,
		DocLink:             vres.DocLink,
		CreatedAt:           vres.CreatedAt,
		UpdatedAt:           vres.UpdatedAt,
		Severity:            vres.Severity,
		Category:            vres.Category,
		Frequency:           vres.Frequency,
		DryRun:              vres.DryRun,
		SkipApprovals:       vres.SkipApprovals,
		Status:              vres.Status,
		Error:               vres.Error,
		ErroredAt:           vres.ErroredAt,
		Scope:               vres.Scope,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentviewsProjectViewToProject(vres.Project)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = transformIncidentviewsPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = transformIncidentviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]string, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			tv := val
			res.Credentials[tk] = tv
		}
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateLink(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicySource converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicySource(vres *incidentviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		PolicyAggregateID:   vres.PolicyAggregateID,
		IncidentAggregateID: vres.IncidentAggregateID,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentviewsProjectViewToProject(vres.Project)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = transformIncidentviewsPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateSource(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicyLink converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicyLink(vres *incidentviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		PolicyAggregateID:   vres.PolicyAggregateID,
		IncidentAggregateID: vres.IncidentAggregateID,
		CreatedAt:           vres.CreatedAt,
		Frequency:           vres.Frequency,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = transformIncidentviewsPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateLink(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicyView projects result type AppliedPolicy to projected type
// AppliedPolicyView using the "default" view.
func newAppliedPolicyView(res *AppliedPolicy) *incidentviews.AppliedPolicyView {
	vres := &incidentviews.AppliedPolicyView{
		ID:                  &res.ID,
		PolicyAggregateID:   res.PolicyAggregateID,
		IncidentAggregateID: res.IncidentAggregateID,
		Name:                &res.Name,
		Href:                &res.Href,
		Description:         res.Description,
		DocLink:             res.DocLink,
		CreatedAt:           res.CreatedAt,
		UpdatedAt:           res.UpdatedAt,
		Severity:            res.Severity,
		Category:            res.Category,
		Frequency:           res.Frequency,
		DryRun:              res.DryRun,
		SkipApprovals:       res.SkipApprovals,
		Status:              res.Status,
		Error:               res.Error,
		ErroredAt:           res.ErroredAt,
		Scope:               res.Scope,
		Kind:                &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentviewsProjectView(res.Project)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = transformPublishedTemplateToIncidentviewsPublishedTemplateView(res.PublishedTemplate)
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentviewsUserView(res.CreatedBy)
	}
	if res.Options != nil {
		vres.Options = make([]*incidentviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = transformConfigurationOptionToIncidentviewsConfigurationOptionView(val)
		}
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]string, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			tv := val
			vres.Credentials[tk] = tv
		}
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewLink(res.PolicyTemplate)
	}
	return vres
}

// newAppliedPolicyViewSource projects result type AppliedPolicy to projected
// type AppliedPolicyView using the "source" view.
func newAppliedPolicyViewSource(res *AppliedPolicy) *incidentviews.AppliedPolicyView {
	vres := &incidentviews.AppliedPolicyView{
		ID:                  &res.ID,
		PolicyAggregateID:   res.PolicyAggregateID,
		IncidentAggregateID: res.IncidentAggregateID,
		Name:                &res.Name,
		Href:                &res.Href,
		Kind:                &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentviewsProjectView(res.Project)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = transformPublishedTemplateToIncidentviewsPublishedTemplateView(res.PublishedTemplate)
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewSource(res.PolicyTemplate)
	}
	return vres
}

// newAppliedPolicyViewLink projects result type AppliedPolicy to projected
// type AppliedPolicyView using the "link" view.
func newAppliedPolicyViewLink(res *AppliedPolicy) *incidentviews.AppliedPolicyView {
	vres := &incidentviews.AppliedPolicyView{
		ID:                  &res.ID,
		PolicyAggregateID:   res.PolicyAggregateID,
		IncidentAggregateID: res.IncidentAggregateID,
		Name:                &res.Name,
		Href:                &res.Href,
		CreatedAt:           res.CreatedAt,
		Frequency:           res.Frequency,
		Kind:                &res.Kind,
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = transformPublishedTemplateToIncidentviewsPublishedTemplateView(res.PublishedTemplate)
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentviewsUserView(res.CreatedBy)
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewLink(res.PolicyTemplate)
	}
	return vres
}

// newPolicyTemplate converts projected type PolicyTemplate to service type
// PolicyTemplate.
func newPolicyTemplate(vres *incidentviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		ProjectID:        vres.ProjectID,
		RsPtVer:          vres.RsPtVer,
		ShortDescription: vres.ShortDescription,
		DocLink:          vres.DocLink,
		DefaultFrequency: vres.DefaultFrequency,
		Category:         vres.Category,
		CreatedAt:        vres.CreatedAt,
		UpdatedAt:        vres.UpdatedAt,
		Severity:         vres.Severity,
		Tenancy:          vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	return res
}

// newPolicyTemplateExtended converts projected type PolicyTemplate to service
// type PolicyTemplate.
func newPolicyTemplateExtended(vres *incidentviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		ProjectID:        vres.ProjectID,
		RsPtVer:          vres.RsPtVer,
		ShortDescription: vres.ShortDescription,
		LongDescription:  vres.LongDescription,
		DocLink:          vres.DocLink,
		DefaultFrequency: vres.DefaultFrequency,
		Category:         vres.Category,
		CreatedAt:        vres.CreatedAt,
		UpdatedAt:        vres.UpdatedAt,
		Severity:         vres.Severity,
		Tenancy:          vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(vres.Permissions))
		for key, val := range vres.Permissions {
			tk := key
			res.Permissions[tk] = transformIncidentviewsPermissionViewToPermission(val)
		}
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentviewsParameterViewToParameter(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]*Credentials, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			res.Credentials[tk] = transformIncidentviewsCredentialsViewToCredentials(val)
		}
	}
	return res
}

// newPolicyTemplateSource converts projected type PolicyTemplate to service
// type PolicyTemplate.
func newPolicyTemplateSource(vres *incidentviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		Filename: vres.Filename,
		Source:   vres.Source,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	return res
}

// newPolicyTemplateLink converts projected type PolicyTemplate to service type
// PolicyTemplate.
func newPolicyTemplateLink(vres *incidentviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		UpdatedAt: vres.UpdatedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentviewsUserViewToUser(vres.UpdatedBy)
	}
	return res
}

// newPolicyTemplateView projects result type PolicyTemplate to projected type
// PolicyTemplateView using the "default" view.
func newPolicyTemplateView(res *PolicyTemplate) *incidentviews.PolicyTemplateView {
	vres := &incidentviews.PolicyTemplateView{
		ID:               &res.ID,
		Name:             &res.Name,
		ProjectID:        res.ProjectID,
		RsPtVer:          res.RsPtVer,
		ShortDescription: res.ShortDescription,
		DocLink:          res.DocLink,
		DefaultFrequency: res.DefaultFrequency,
		Href:             &res.Href,
		Fingerprint:      &res.Fingerprint,
		Category:         res.Category,
		CreatedAt:        res.CreatedAt,
		UpdatedAt:        res.UpdatedAt,
		Severity:         res.Severity,
		Tenancy:          res.Tenancy,
		Kind:             &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentviewsUserView(res.UpdatedBy)
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	return vres
}

// newPolicyTemplateViewExtended projects result type PolicyTemplate to
// projected type PolicyTemplateView using the "extended" view.
func newPolicyTemplateViewExtended(res *PolicyTemplate) *incidentviews.PolicyTemplateView {
	vres := &incidentviews.PolicyTemplateView{
		ID:               &res.ID,
		Name:             &res.Name,
		ProjectID:        res.ProjectID,
		RsPtVer:          res.RsPtVer,
		ShortDescription: res.ShortDescription,
		LongDescription:  res.LongDescription,
		DocLink:          res.DocLink,
		DefaultFrequency: res.DefaultFrequency,
		Href:             &res.Href,
		Fingerprint:      &res.Fingerprint,
		Category:         res.Category,
		CreatedAt:        res.CreatedAt,
		UpdatedAt:        res.UpdatedAt,
		Severity:         res.Severity,
		Tenancy:          res.Tenancy,
		Kind:             &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentviewsUserView(res.UpdatedBy)
	}
	if res.Permissions != nil {
		vres.Permissions = make(map[string]*incidentviews.PermissionView, len(res.Permissions))
		for key, val := range res.Permissions {
			tk := key
			vres.Permissions[tk] = transformPermissionToIncidentviewsPermissionView(val)
		}
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*incidentviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			vres.Parameters[tk] = transformParameterToIncidentviewsParameterView(val)
		}
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]*incidentviews.CredentialsView, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			vres.Credentials[tk] = transformCredentialsToIncidentviewsCredentialsView(val)
		}
	}
	return vres
}

// newPolicyTemplateViewSource projects result type PolicyTemplate to projected
// type PolicyTemplateView using the "source" view.
func newPolicyTemplateViewSource(res *PolicyTemplate) *incidentviews.PolicyTemplateView {
	vres := &incidentviews.PolicyTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Filename:    res.Filename,
		Source:      res.Source,
		Fingerprint: &res.Fingerprint,
		Kind:        &res.Kind,
	}
	return vres
}

// newPolicyTemplateViewLink projects result type PolicyTemplate to projected
// type PolicyTemplateView using the "link" view.
func newPolicyTemplateViewLink(res *PolicyTemplate) *incidentviews.PolicyTemplateView {
	vres := &incidentviews.PolicyTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Fingerprint: &res.Fingerprint,
		UpdatedAt:   res.UpdatedAt,
		Kind:        &res.Kind,
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentviewsUserView(res.UpdatedBy)
	}
	return vres
}

// newPublishedTemplate converts projected type PublishedTemplate to service
// type PublishedTemplate.
func newPublishedTemplate(vres *incidentviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		OrgID:                     vres.OrgID,
		ProjectID:                 vres.ProjectID,
		PolicyTemplateID:          vres.PolicyTemplateID,
		PolicyTemplateURL:         vres.PolicyTemplateURL,
		PolicyTemplateFingerprint: vres.PolicyTemplateFingerprint,
		RsPtVer:                   vres.RsPtVer,
		ShortDescription:          vres.ShortDescription,
		DocLink:                   vres.DocLink,
		DefaultFrequency:          vres.DefaultFrequency,
		Category:                  vres.Category,
		CreatedAt:                 vres.CreatedAt,
		UpdatedAt:                 vres.UpdatedAt,
		HiddenAt:                  vres.HiddenAt,
		Severity:                  vres.Severity,
		BuiltIn:                   vres.BuiltIn,
		Hidden:                    vres.Hidden,
		Tenancy:                   vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.HiddenBy != nil {
		res.HiddenBy = transformIncidentviewsUserViewToUser(vres.HiddenBy)
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	return res
}

// newPublishedTemplateExtended converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateExtended(vres *incidentviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		OrgID:                     vres.OrgID,
		ProjectID:                 vres.ProjectID,
		PolicyTemplateID:          vres.PolicyTemplateID,
		PolicyTemplateURL:         vres.PolicyTemplateURL,
		PolicyTemplateFingerprint: vres.PolicyTemplateFingerprint,
		RsPtVer:                   vres.RsPtVer,
		ShortDescription:          vres.ShortDescription,
		LongDescription:           vres.LongDescription,
		DocLink:                   vres.DocLink,
		DefaultFrequency:          vres.DefaultFrequency,
		Category:                  vres.Category,
		CreatedAt:                 vres.CreatedAt,
		UpdatedAt:                 vres.UpdatedAt,
		HiddenAt:                  vres.HiddenAt,
		Severity:                  vres.Severity,
		BuiltIn:                   vres.BuiltIn,
		Hidden:                    vres.Hidden,
		Tenancy:                   vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.HiddenBy != nil {
		res.HiddenBy = transformIncidentviewsUserViewToUser(vres.HiddenBy)
	}
	if vres.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(vres.Permissions))
		for key, val := range vres.Permissions {
			tk := key
			res.Permissions[tk] = transformIncidentviewsPermissionViewToPermission(val)
		}
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentviewsParameterViewToParameter(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]*Credentials, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			res.Credentials[tk] = transformIncidentviewsCredentialsViewToCredentials(val)
		}
	}
	return res
}

// newPublishedTemplateSource converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateSource(vres *incidentviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		Filename: vres.Filename,
		Source:   vres.Source,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	return res
}

// newPublishedTemplateLink converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateLink(vres *incidentviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		UpdatedAt: vres.UpdatedAt,
		BuiltIn:   vres.BuiltIn,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentviewsUserViewToUser(vres.UpdatedBy)
	}
	return res
}

// newPublishedTemplateView projects result type PublishedTemplate to projected
// type PublishedTemplateView using the "default" view.
func newPublishedTemplateView(res *PublishedTemplate) *incidentviews.PublishedTemplateView {
	vres := &incidentviews.PublishedTemplateView{
		ID:                        &res.ID,
		Name:                      &res.Name,
		OrgID:                     res.OrgID,
		ProjectID:                 res.ProjectID,
		PolicyTemplateID:          res.PolicyTemplateID,
		PolicyTemplateURL:         res.PolicyTemplateURL,
		PolicyTemplateFingerprint: res.PolicyTemplateFingerprint,
		RsPtVer:                   res.RsPtVer,
		ShortDescription:          res.ShortDescription,
		DocLink:                   res.DocLink,
		DefaultFrequency:          res.DefaultFrequency,
		Href:                      &res.Href,
		Fingerprint:               &res.Fingerprint,
		Category:                  res.Category,
		CreatedAt:                 res.CreatedAt,
		UpdatedAt:                 res.UpdatedAt,
		Severity:                  res.Severity,
		BuiltIn:                   res.BuiltIn,
		Hidden:                    res.Hidden,
		HiddenAt:                  res.HiddenAt,
		Tenancy:                   res.Tenancy,
		Kind:                      &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentviewsUserView(res.UpdatedBy)
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.HiddenBy != nil {
		vres.HiddenBy = transformUserToIncidentviewsUserView(res.HiddenBy)
	}
	return vres
}

// newPublishedTemplateViewExtended projects result type PublishedTemplate to
// projected type PublishedTemplateView using the "extended" view.
func newPublishedTemplateViewExtended(res *PublishedTemplate) *incidentviews.PublishedTemplateView {
	vres := &incidentviews.PublishedTemplateView{
		ID:                        &res.ID,
		Name:                      &res.Name,
		OrgID:                     res.OrgID,
		ProjectID:                 res.ProjectID,
		PolicyTemplateID:          res.PolicyTemplateID,
		PolicyTemplateURL:         res.PolicyTemplateURL,
		PolicyTemplateFingerprint: res.PolicyTemplateFingerprint,
		RsPtVer:                   res.RsPtVer,
		ShortDescription:          res.ShortDescription,
		LongDescription:           res.LongDescription,
		DocLink:                   res.DocLink,
		DefaultFrequency:          res.DefaultFrequency,
		Href:                      &res.Href,
		Fingerprint:               &res.Fingerprint,
		Category:                  res.Category,
		CreatedAt:                 res.CreatedAt,
		UpdatedAt:                 res.UpdatedAt,
		Severity:                  res.Severity,
		BuiltIn:                   res.BuiltIn,
		Hidden:                    res.Hidden,
		HiddenAt:                  res.HiddenAt,
		Tenancy:                   res.Tenancy,
		Kind:                      &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentviewsUserView(res.UpdatedBy)
	}
	if res.Permissions != nil {
		vres.Permissions = make(map[string]*incidentviews.PermissionView, len(res.Permissions))
		for key, val := range res.Permissions {
			tk := key
			vres.Permissions[tk] = transformPermissionToIncidentviewsPermissionView(val)
		}
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*incidentviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			vres.Parameters[tk] = transformParameterToIncidentviewsParameterView(val)
		}
	}
	if res.HiddenBy != nil {
		vres.HiddenBy = transformUserToIncidentviewsUserView(res.HiddenBy)
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]*incidentviews.CredentialsView, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			vres.Credentials[tk] = transformCredentialsToIncidentviewsCredentialsView(val)
		}
	}
	return vres
}

// newPublishedTemplateViewSource projects result type PublishedTemplate to
// projected type PublishedTemplateView using the "source" view.
func newPublishedTemplateViewSource(res *PublishedTemplate) *incidentviews.PublishedTemplateView {
	vres := &incidentviews.PublishedTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Filename:    res.Filename,
		Source:      res.Source,
		Fingerprint: &res.Fingerprint,
		Kind:        &res.Kind,
	}
	return vres
}

// newPublishedTemplateViewLink projects result type PublishedTemplate to
// projected type PublishedTemplateView using the "link" view.
func newPublishedTemplateViewLink(res *PublishedTemplate) *incidentviews.PublishedTemplateView {
	vres := &incidentviews.PublishedTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Fingerprint: &res.Fingerprint,
		UpdatedAt:   res.UpdatedAt,
		BuiltIn:     res.BuiltIn,
		Kind:        &res.Kind,
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentviewsUserView(res.UpdatedBy)
	}
	return vres
}

// newAction converts projected type Action to service type Action.
func newAction(vres *incidentviews.ActionView) *Action {
	res := &Action{
		Label:       vres.Label,
		Description: vres.Description,
		Automatic:   vres.Automatic,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Type != nil {
		res.Type = *vres.Type
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentviewsParameterViewToParameter(val)
		}
	}
	return res
}

// newActionView projects result type Action to projected type ActionView using
// the "default" view.
func newActionView(res *Action) *incidentviews.ActionView {
	vres := &incidentviews.ActionView{
		ID:          &res.ID,
		Type:        &res.Type,
		Label:       res.Label,
		Description: res.Description,
		Automatic:   res.Automatic,
		Kind:        &res.Kind,
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*incidentviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			vres.Parameters[tk] = transformParameterToIncidentviewsParameterView(val)
		}
	}
	return vres
}

// newIncidentList converts projected type IncidentList to service type
// IncidentList.
func newIncidentList(vres *incidentviews.IncidentListView) *IncidentList {
	res := &IncidentList{
		Count:       vres.Count,
		NotModified: vres.NotModified,
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Items != nil {
		res.Items = newIncidentCollection(vres.Items)
	}
	return res
}

// newIncidentListView projects result type IncidentList to projected type
// IncidentListView using the "default" view.
func newIncidentListView(res *IncidentList) *incidentviews.IncidentListView {
	vres := &incidentviews.IncidentListView{
		Count:       res.Count,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
		Kind:        &res.Kind,
	}
	if res.Items != nil {
		vres.Items = newIncidentCollectionView(res.Items)
	}
	return vres
}

// newIncidentCollection converts projected type IncidentCollection to service
// type IncidentCollection.
func newIncidentCollection(vres incidentviews.IncidentCollectionView) IncidentCollection {
	res := make(IncidentCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncident(n)
	}
	return res
}

// newIncidentCollectionExtended converts projected type IncidentCollection to
// service type IncidentCollection.
func newIncidentCollectionExtended(vres incidentviews.IncidentCollectionView) IncidentCollection {
	res := make(IncidentCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncidentExtended(n)
	}
	return res
}

// newIncidentCollectionSource converts projected type IncidentCollection to
// service type IncidentCollection.
func newIncidentCollectionSource(vres incidentviews.IncidentCollectionView) IncidentCollection {
	res := make(IncidentCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncidentSource(n)
	}
	return res
}

// newIncidentCollectionView projects result type IncidentCollection to
// projected type IncidentCollectionView using the "default" view.
func newIncidentCollectionView(res IncidentCollection) incidentviews.IncidentCollectionView {
	vres := make(incidentviews.IncidentCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentView(n)
	}
	return vres
}

// newIncidentCollectionViewExtended projects result type IncidentCollection to
// projected type IncidentCollectionView using the "extended" view.
func newIncidentCollectionViewExtended(res IncidentCollection) incidentviews.IncidentCollectionView {
	vres := make(incidentviews.IncidentCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentViewExtended(n)
	}
	return vres
}

// newIncidentCollectionViewSource projects result type IncidentCollection to
// projected type IncidentCollectionView using the "source" view.
func newIncidentCollectionViewSource(res IncidentCollection) incidentviews.IncidentCollectionView {
	vres := make(incidentviews.IncidentCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentViewSource(n)
	}
	return vres
}

// newEscalations converts projected type Escalations to service type
// Escalations.
func newEscalations(vres *incidentviews.EscalationsView) *Escalations {
	res := &Escalations{
		StartedAt:  vres.StartedAt,
		FinishedAt: vres.FinishedAt,
	}
	if vres.Status != nil {
		res.Status = *vres.Status
	}
	if vres.Escalations != nil {
		res.Escalations = make([]*Escalation, len(vres.Escalations))
		for i, val := range vres.Escalations {
			res.Escalations[i] = transformIncidentviewsEscalationViewToEscalation(val)
		}
	}
	return res
}

// newEscalationsView projects result type Escalations to projected type
// EscalationsView using the "default" view.
func newEscalationsView(res *Escalations) *incidentviews.EscalationsView {
	vres := &incidentviews.EscalationsView{
		Status:     &res.Status,
		StartedAt:  res.StartedAt,
		FinishedAt: res.FinishedAt,
	}
	if res.Escalations != nil {
		vres.Escalations = make([]*incidentviews.EscalationView, len(res.Escalations))
		for i, val := range res.Escalations {
			vres.Escalations[i] = transformEscalationToIncidentviewsEscalationView(val)
		}
	}
	return vres
}

// newEscalation converts projected type Escalation to service type Escalation.
func newEscalation(vres *incidentviews.EscalationView) *Escalation {
	res := &Escalation{}
	if vres.Status != nil {
		res.Status = *vres.Status
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Actions != nil {
		res.Actions = make([]*EscalationAction, len(vres.Actions))
		for i, val := range vres.Actions {
			res.Actions[i] = transformIncidentviewsEscalationActionViewToEscalationAction(val)
		}
	}
	return res
}

// newEscalationView projects result type Escalation to projected type
// EscalationView using the "default" view.
func newEscalationView(res *Escalation) *incidentviews.EscalationView {
	vres := &incidentviews.EscalationView{
		Status: &res.Status,
		Name:   &res.Name,
	}
	if res.Actions != nil {
		vres.Actions = make([]*incidentviews.EscalationActionView, len(res.Actions))
		for i, val := range res.Actions {
			vres.Actions[i] = transformEscalationActionToIncidentviewsEscalationActionView(val)
		}
	}
	return vres
}

// newEscalationAction converts projected type EscalationAction to service type
// EscalationAction.
func newEscalationAction(vres *incidentviews.EscalationActionView) *EscalationAction {
	res := &EscalationAction{
		StartedAt:   vres.StartedAt,
		FinishedAt:  vres.FinishedAt,
		Error:       vres.Error,
		ProcessHref: vres.ProcessHref,
	}
	if vres.Type != nil {
		res.Type = *vres.Type
	}
	if vres.Status != nil {
		res.Status = *vres.Status
	}
	if vres.ApprovalRequest != nil {
		res.ApprovalRequest = newApprovalRequestExtended(vres.ApprovalRequest)
	}
	return res
}

// newEscalationActionView projects result type EscalationAction to projected
// type EscalationActionView using the "default" view.
func newEscalationActionView(res *EscalationAction) *incidentviews.EscalationActionView {
	vres := &incidentviews.EscalationActionView{
		Type:        &res.Type,
		Status:      &res.Status,
		StartedAt:   res.StartedAt,
		FinishedAt:  res.FinishedAt,
		Error:       res.Error,
		ProcessHref: res.ProcessHref,
	}
	if res.ApprovalRequest != nil {
		vres.ApprovalRequest = newApprovalRequestViewExtended(res.ApprovalRequest)
	}
	return vres
}

// newApprovalRequest converts projected type ApprovalRequest to service type
// ApprovalRequest.
func newApprovalRequest(vres *incidentviews.ApprovalRequestView) *ApprovalRequest {
	res := &ApprovalRequest{
		Label:       vres.Label,
		Description: vres.Description,
		CreatedAt:   vres.CreatedAt,
		UpdatedAt:   vres.UpdatedAt,
		Status:      vres.Status,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.ProjectID != nil {
		res.ProjectID = *vres.ProjectID
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Subject != nil {
		res.Subject = transformIncidentviewsApprovalSubjectToApprovalSubject(vres.Subject)
	}
	return res
}

// newApprovalRequestExtended converts projected type ApprovalRequest to
// service type ApprovalRequest.
func newApprovalRequestExtended(vres *incidentviews.ApprovalRequestView) *ApprovalRequest {
	res := &ApprovalRequest{
		Label:         vres.Label,
		Description:   vres.Description,
		CreatedAt:     vres.CreatedAt,
		UpdatedAt:     vres.UpdatedAt,
		Status:        vres.Status,
		ApprovedAt:    vres.ApprovedAt,
		DenialComment: vres.DenialComment,
		DeniedAt:      vres.DeniedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.ProjectID != nil {
		res.ProjectID = *vres.ProjectID
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Subject != nil {
		res.Subject = transformIncidentviewsApprovalSubjectToApprovalSubject(vres.Subject)
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentviewsParameterViewToParameter(val)
		}
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = transformIncidentviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if vres.ApprovedBy != nil {
		res.ApprovedBy = transformIncidentviewsUserViewToUser(vres.ApprovedBy)
	}
	if vres.DeniedBy != nil {
		res.DeniedBy = transformIncidentviewsUserViewToUser(vres.DeniedBy)
	}
	return res
}

// newApprovalRequestView projects result type ApprovalRequest to projected
// type ApprovalRequestView using the "default" view.
func newApprovalRequestView(res *ApprovalRequest) *incidentviews.ApprovalRequestView {
	vres := &incidentviews.ApprovalRequestView{
		ID:          &res.ID,
		ProjectID:   &res.ProjectID,
		Href:        &res.Href,
		Label:       res.Label,
		Description: res.Description,
		CreatedAt:   res.CreatedAt,
		UpdatedAt:   res.UpdatedAt,
		Status:      res.Status,
		Kind:        &res.Kind,
	}
	if res.Subject != nil {
		vres.Subject = transformApprovalSubjectToIncidentviewsApprovalSubject(res.Subject)
	}
	return vres
}

// newApprovalRequestViewExtended projects result type ApprovalRequest to
// projected type ApprovalRequestView using the "extended" view.
func newApprovalRequestViewExtended(res *ApprovalRequest) *incidentviews.ApprovalRequestView {
	vres := &incidentviews.ApprovalRequestView{
		ID:            &res.ID,
		ProjectID:     &res.ProjectID,
		Href:          &res.Href,
		Label:         res.Label,
		Description:   res.Description,
		CreatedAt:     res.CreatedAt,
		UpdatedAt:     res.UpdatedAt,
		Status:        res.Status,
		ApprovedAt:    res.ApprovedAt,
		DenialComment: res.DenialComment,
		DeniedAt:      res.DeniedAt,
		Kind:          &res.Kind,
	}
	if res.Subject != nil {
		vres.Subject = transformApprovalSubjectToIncidentviewsApprovalSubject(res.Subject)
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*incidentviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			vres.Parameters[tk] = transformParameterToIncidentviewsParameterView(val)
		}
	}
	if res.Options != nil {
		vres.Options = make([]*incidentviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = transformConfigurationOptionToIncidentviewsConfigurationOptionView(val)
		}
	}
	if res.ApprovedBy != nil {
		vres.ApprovedBy = transformUserToIncidentviewsUserView(res.ApprovedBy)
	}
	if res.DeniedBy != nil {
		vres.DeniedBy = transformUserToIncidentviewsUserView(res.DeniedBy)
	}
	return vres
}

// newResolutions converts projected type Resolutions to service type
// Resolutions.
func newResolutions(vres *incidentviews.ResolutionsView) *Resolutions {
	res := &Resolutions{
		StartedAt:  vres.StartedAt,
		FinishedAt: vres.FinishedAt,
	}
	if vres.Status != nil {
		res.Status = *vres.Status
	}
	if vres.Resolutions != nil {
		res.Resolutions = make([]*Resolution, len(vres.Resolutions))
		for i, val := range vres.Resolutions {
			res.Resolutions[i] = transformIncidentviewsResolutionViewToResolution(val)
		}
	}
	return res
}

// newResolutionsView projects result type Resolutions to projected type
// ResolutionsView using the "default" view.
func newResolutionsView(res *Resolutions) *incidentviews.ResolutionsView {
	vres := &incidentviews.ResolutionsView{
		Status:     &res.Status,
		StartedAt:  res.StartedAt,
		FinishedAt: res.FinishedAt,
	}
	if res.Resolutions != nil {
		vres.Resolutions = make([]*incidentviews.ResolutionView, len(res.Resolutions))
		for i, val := range res.Resolutions {
			vres.Resolutions[i] = transformResolutionToIncidentviewsResolutionView(val)
		}
	}
	return vres
}

// newResolution converts projected type Resolution to service type Resolution.
func newResolution(vres *incidentviews.ResolutionView) *Resolution {
	res := &Resolution{}
	if vres.Status != nil {
		res.Status = *vres.Status
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Actions != nil {
		res.Actions = make([]*ResolutionAction, len(vres.Actions))
		for i, val := range vres.Actions {
			res.Actions[i] = transformIncidentviewsResolutionActionViewToResolutionAction(val)
		}
	}
	return res
}

// newResolutionView projects result type Resolution to projected type
// ResolutionView using the "default" view.
func newResolutionView(res *Resolution) *incidentviews.ResolutionView {
	vres := &incidentviews.ResolutionView{
		Status: &res.Status,
		Name:   &res.Name,
	}
	if res.Actions != nil {
		vres.Actions = make([]*incidentviews.ResolutionActionView, len(res.Actions))
		for i, val := range res.Actions {
			vres.Actions[i] = transformResolutionActionToIncidentviewsResolutionActionView(val)
		}
	}
	return vres
}

// newResolutionAction converts projected type ResolutionAction to service type
// ResolutionAction.
func newResolutionAction(vres *incidentviews.ResolutionActionView) *ResolutionAction {
	res := &ResolutionAction{
		StartedAt:   vres.StartedAt,
		FinishedAt:  vres.FinishedAt,
		Error:       vres.Error,
		ProcessHref: vres.ProcessHref,
	}
	if vres.Type != nil {
		res.Type = *vres.Type
	}
	if vres.Status != nil {
		res.Status = *vres.Status
	}
	if vres.ApprovalRequest != nil {
		res.ApprovalRequest = newApprovalRequestExtended(vres.ApprovalRequest)
	}
	return res
}

// newResolutionActionView projects result type ResolutionAction to projected
// type ResolutionActionView using the "default" view.
func newResolutionActionView(res *ResolutionAction) *incidentviews.ResolutionActionView {
	vres := &incidentviews.ResolutionActionView{
		Type:        &res.Type,
		Status:      &res.Status,
		StartedAt:   res.StartedAt,
		FinishedAt:  res.FinishedAt,
		Error:       res.Error,
		ProcessHref: res.ProcessHref,
	}
	if res.ApprovalRequest != nil {
		vres.ApprovalRequest = newApprovalRequestViewExtended(res.ApprovalRequest)
	}
	return vres
}

// transformIncidentviewsProjectViewToProject builds a value of type *Project
// from a value of type *incidentviews.ProjectView.
func transformIncidentviewsProjectViewToProject(v *incidentviews.ProjectView) *Project {
	if v == nil {
		return nil
	}
	res := &Project{
		ID:      *v.ID,
		Name:    *v.Name,
		OrgID:   *v.OrgID,
		OrgName: *v.OrgName,
	}

	return res
}

// transformIncidentviewsUserViewToUser builds a value of type *User from a
// value of type *incidentviews.UserView.
func transformIncidentviewsUserViewToUser(v *incidentviews.UserView) *User {
	if v == nil {
		return nil
	}
	res := &User{
		ID:    *v.ID,
		Email: *v.Email,
		Name:  *v.Name,
	}

	return res
}

// transformIncidentviewsConfigurationOptionViewToConfigurationOption builds a
// value of type *ConfigurationOption from a value of type
// *incidentviews.ConfigurationOptionView.
func transformIncidentviewsConfigurationOptionViewToConfigurationOption(v *incidentviews.ConfigurationOptionView) *ConfigurationOption {
	if v == nil {
		return nil
	}
	res := &ConfigurationOption{
		Name:  *v.Name,
		Label: *v.Label,
		Type:  *v.Type,
		Value: v.Value,
	}
	if v.NoEcho != nil {
		res.NoEcho = *v.NoEcho
	}
	if v.NoEcho == nil {
		res.NoEcho = false
	}

	return res
}

// transformIncidentviewsActionViewToAction builds a value of type *Action from
// a value of type *incidentviews.ActionView.
func transformIncidentviewsActionViewToAction(v *incidentviews.ActionView) *Action {
	if v == nil {
		return nil
	}
	res := &Action{
		ID:          *v.ID,
		Type:        *v.Type,
		Label:       v.Label,
		Description: v.Description,
		Automatic:   v.Automatic,
		Kind:        *v.Kind,
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentviewsParameterViewToParameter(val)
		}
	}

	return res
}

// transformIncidentviewsParameterViewToParameter builds a value of type
// *Parameter from a value of type *incidentviews.ParameterView.
func transformIncidentviewsParameterViewToParameter(v *incidentviews.ParameterView) *Parameter {
	if v == nil {
		return nil
	}
	res := &Parameter{
		Name:                  *v.Name,
		Type:                  *v.Type,
		Label:                 *v.Label,
		Index:                 *v.Index,
		Category:              v.Category,
		Description:           v.Description,
		Default:               v.Default,
		MinLength:             v.MinLength,
		MaxLength:             v.MaxLength,
		MinValue:              v.MinValue,
		MaxValue:              v.MaxValue,
		ConstraintDescription: v.ConstraintDescription,
	}
	if v.NoEcho != nil {
		res.NoEcho = *v.NoEcho
	}
	if v.NoEcho == nil {
		res.NoEcho = false
	}
	if v.AllowedValues != nil {
		res.AllowedValues = make([]interface{}, len(v.AllowedValues))
		for i, val := range v.AllowedValues {
			res.AllowedValues[i] = val
		}
	}
	if v.AllowedPattern != nil {
		res.AllowedPattern = transformIncidentviewsRegexpViewToRegexp(v.AllowedPattern)
	}

	return res
}

// transformIncidentviewsRegexpViewToRegexp builds a value of type *Regexp from
// a value of type *incidentviews.RegexpView.
func transformIncidentviewsRegexpViewToRegexp(v *incidentviews.RegexpView) *Regexp {
	if v == nil {
		return nil
	}
	res := &Regexp{
		Pattern: *v.Pattern,
		Options: v.Options,
	}

	return res
}

// transformIncidentviewsDataFieldViewToDataField builds a value of type
// *DataField from a value of type *incidentviews.DataFieldView.
func transformIncidentviewsDataFieldViewToDataField(v *incidentviews.DataFieldView) *DataField {
	if v == nil {
		return nil
	}
	res := &DataField{
		Key:    *v.Key,
		Label:  v.Label,
		Format: v.Format,
	}

	return res
}

// transformProjectToIncidentviewsProjectView builds a value of type
// *incidentviews.ProjectView from a value of type *Project.
func transformProjectToIncidentviewsProjectView(v *Project) *incidentviews.ProjectView {
	if v == nil {
		return nil
	}
	res := &incidentviews.ProjectView{
		ID:      &v.ID,
		Name:    &v.Name,
		OrgID:   &v.OrgID,
		OrgName: &v.OrgName,
	}

	return res
}

// transformUserToIncidentviewsUserView builds a value of type
// *incidentviews.UserView from a value of type *User.
func transformUserToIncidentviewsUserView(v *User) *incidentviews.UserView {
	if v == nil {
		return nil
	}
	res := &incidentviews.UserView{
		ID:    &v.ID,
		Email: &v.Email,
		Name:  &v.Name,
	}

	return res
}

// transformConfigurationOptionToIncidentviewsConfigurationOptionView builds a
// value of type *incidentviews.ConfigurationOptionView from a value of type
// *ConfigurationOption.
func transformConfigurationOptionToIncidentviewsConfigurationOptionView(v *ConfigurationOption) *incidentviews.ConfigurationOptionView {
	if v == nil {
		return nil
	}
	res := &incidentviews.ConfigurationOptionView{
		Name:   &v.Name,
		Label:  &v.Label,
		Type:   &v.Type,
		Value:  v.Value,
		NoEcho: &v.NoEcho,
	}

	return res
}

// transformDataFieldToIncidentviewsDataFieldView builds a value of type
// *incidentviews.DataFieldView from a value of type *DataField.
func transformDataFieldToIncidentviewsDataFieldView(v *DataField) *incidentviews.DataFieldView {
	if v == nil {
		return nil
	}
	res := &incidentviews.DataFieldView{
		Key:    &v.Key,
		Label:  v.Label,
		Format: v.Format,
	}

	return res
}

// transformActionToIncidentviewsActionView builds a value of type
// *incidentviews.ActionView from a value of type *Action.
func transformActionToIncidentviewsActionView(v *Action) *incidentviews.ActionView {
	if v == nil {
		return nil
	}
	res := &incidentviews.ActionView{
		ID:          &v.ID,
		Type:        &v.Type,
		Label:       v.Label,
		Description: v.Description,
		Automatic:   v.Automatic,
		Kind:        &v.Kind,
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*incidentviews.ParameterView, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformParameterToIncidentviewsParameterView(val)
		}
	}

	return res
}

// transformParameterToIncidentviewsParameterView builds a value of type
// *incidentviews.ParameterView from a value of type *Parameter.
func transformParameterToIncidentviewsParameterView(v *Parameter) *incidentviews.ParameterView {
	if v == nil {
		return nil
	}
	res := &incidentviews.ParameterView{
		Name:                  &v.Name,
		Type:                  &v.Type,
		Label:                 &v.Label,
		Index:                 &v.Index,
		Category:              v.Category,
		Description:           v.Description,
		Default:               v.Default,
		NoEcho:                &v.NoEcho,
		MinLength:             v.MinLength,
		MaxLength:             v.MaxLength,
		MinValue:              v.MinValue,
		MaxValue:              v.MaxValue,
		ConstraintDescription: v.ConstraintDescription,
	}
	if v.AllowedValues != nil {
		res.AllowedValues = make([]interface{}, len(v.AllowedValues))
		for i, val := range v.AllowedValues {
			res.AllowedValues[i] = val
		}
	}
	if v.AllowedPattern != nil {
		res.AllowedPattern = transformRegexpToIncidentviewsRegexpView(v.AllowedPattern)
	}

	return res
}

// transformRegexpToIncidentviewsRegexpView builds a value of type
// *incidentviews.RegexpView from a value of type *Regexp.
func transformRegexpToIncidentviewsRegexpView(v *Regexp) *incidentviews.RegexpView {
	if v == nil {
		return nil
	}
	res := &incidentviews.RegexpView{
		Pattern: &v.Pattern,
		Options: v.Options,
	}

	return res
}

// transformIncidentviewsPublishedTemplateViewToPublishedTemplate builds a
// value of type *PublishedTemplate from a value of type
// *incidentviews.PublishedTemplateView.
func transformIncidentviewsPublishedTemplateViewToPublishedTemplate(v *incidentviews.PublishedTemplateView) *PublishedTemplate {
	if v == nil {
		return nil
	}
	res := &PublishedTemplate{
		ID:                        *v.ID,
		Name:                      *v.Name,
		OrgID:                     v.OrgID,
		ProjectID:                 v.ProjectID,
		PolicyTemplateID:          v.PolicyTemplateID,
		PolicyTemplateURL:         v.PolicyTemplateURL,
		PolicyTemplateFingerprint: v.PolicyTemplateFingerprint,
		RsPtVer:                   v.RsPtVer,
		ShortDescription:          v.ShortDescription,
		LongDescription:           v.LongDescription,
		DocLink:                   v.DocLink,
		DefaultFrequency:          v.DefaultFrequency,
		Href:                      *v.Href,
		Filename:                  v.Filename,
		Source:                    v.Source,
		Fingerprint:               *v.Fingerprint,
		Category:                  v.Category,
		CreatedAt:                 v.CreatedAt,
		UpdatedAt:                 v.UpdatedAt,
		Severity:                  v.Severity,
		BuiltIn:                   v.BuiltIn,
		Hidden:                    v.Hidden,
		HiddenAt:                  v.HiddenAt,
		Tenancy:                   v.Tenancy,
		Kind:                      *v.Kind,
	}
	if v.Info != nil {
		res.Info = make(map[string]string, len(v.Info))
		for key, val := range v.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if v.CreatedBy != nil {
		res.CreatedBy = transformIncidentviewsUserViewToUser(v.CreatedBy)
	}
	if v.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentviewsUserViewToUser(v.UpdatedBy)
	}
	if v.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(v.Permissions))
		for key, val := range v.Permissions {
			tk := key
			res.Permissions[tk] = transformIncidentviewsPermissionViewToPermission(val)
		}
	}
	if v.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(v.RequiredRoles))
		for i, val := range v.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentviewsParameterViewToParameter(val)
		}
	}
	if v.HiddenBy != nil {
		res.HiddenBy = transformIncidentviewsUserViewToUser(v.HiddenBy)
	}
	if v.Credentials != nil {
		res.Credentials = make(map[string]*Credentials, len(v.Credentials))
		for key, val := range v.Credentials {
			tk := key
			res.Credentials[tk] = transformIncidentviewsCredentialsViewToCredentials(val)
		}
	}

	return res
}

// transformIncidentviewsPermissionViewToPermission builds a value of type
// *Permission from a value of type *incidentviews.PermissionView.
func transformIncidentviewsPermissionViewToPermission(v *incidentviews.PermissionView) *Permission {
	if v == nil {
		return nil
	}
	res := &Permission{
		Name:  *v.Name,
		Label: v.Label,
	}
	if v.Resources != nil {
		res.Resources = make([]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = val
		}
	}
	if v.Actions != nil {
		res.Actions = make([]string, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = val
		}
	}

	return res
}

// transformIncidentviewsCredentialsViewToCredentials builds a value of type
// *Credentials from a value of type *incidentviews.CredentialsView.
func transformIncidentviewsCredentialsViewToCredentials(v *incidentviews.CredentialsView) *Credentials {
	if v == nil {
		return nil
	}
	res := &Credentials{
		Name:        *v.Name,
		Label:       *v.Label,
		Description: v.Description,
	}
	if v.Schemes != nil {
		res.Schemes = make([]string, len(v.Schemes))
		for i, val := range v.Schemes {
			res.Schemes[i] = val
		}
	}
	if v.Tags != nil {
		res.Tags = make([]*CredentialsTag, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = transformIncidentviewsCredentialsTagViewToCredentialsTag(val)
		}
	}

	return res
}

// transformIncidentviewsCredentialsTagViewToCredentialsTag builds a value of
// type *CredentialsTag from a value of type *incidentviews.CredentialsTagView.
func transformIncidentviewsCredentialsTagViewToCredentialsTag(v *incidentviews.CredentialsTagView) *CredentialsTag {
	if v == nil {
		return nil
	}
	res := &CredentialsTag{
		Key:   *v.Key,
		Value: *v.Value,
	}

	return res
}

// transformPublishedTemplateToIncidentviewsPublishedTemplateView builds a
// value of type *incidentviews.PublishedTemplateView from a value of type
// *PublishedTemplate.
func transformPublishedTemplateToIncidentviewsPublishedTemplateView(v *PublishedTemplate) *incidentviews.PublishedTemplateView {
	if v == nil {
		return nil
	}
	res := &incidentviews.PublishedTemplateView{
		ID:                        &v.ID,
		Name:                      &v.Name,
		OrgID:                     v.OrgID,
		ProjectID:                 v.ProjectID,
		PolicyTemplateID:          v.PolicyTemplateID,
		PolicyTemplateURL:         v.PolicyTemplateURL,
		PolicyTemplateFingerprint: v.PolicyTemplateFingerprint,
		RsPtVer:                   v.RsPtVer,
		ShortDescription:          v.ShortDescription,
		LongDescription:           v.LongDescription,
		DocLink:                   v.DocLink,
		DefaultFrequency:          v.DefaultFrequency,
		Href:                      &v.Href,
		Filename:                  v.Filename,
		Source:                    v.Source,
		Fingerprint:               &v.Fingerprint,
		Category:                  v.Category,
		CreatedAt:                 v.CreatedAt,
		UpdatedAt:                 v.UpdatedAt,
		Severity:                  v.Severity,
		BuiltIn:                   v.BuiltIn,
		Hidden:                    v.Hidden,
		HiddenAt:                  v.HiddenAt,
		Tenancy:                   v.Tenancy,
		Kind:                      &v.Kind,
	}
	if v.Info != nil {
		res.Info = make(map[string]string, len(v.Info))
		for key, val := range v.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if v.CreatedBy != nil {
		res.CreatedBy = transformUserToIncidentviewsUserView(v.CreatedBy)
	}
	if v.UpdatedBy != nil {
		res.UpdatedBy = transformUserToIncidentviewsUserView(v.UpdatedBy)
	}
	if v.Permissions != nil {
		res.Permissions = make(map[string]*incidentviews.PermissionView, len(v.Permissions))
		for key, val := range v.Permissions {
			tk := key
			res.Permissions[tk] = transformPermissionToIncidentviewsPermissionView(val)
		}
	}
	if v.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(v.RequiredRoles))
		for i, val := range v.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*incidentviews.ParameterView, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformParameterToIncidentviewsParameterView(val)
		}
	}
	if v.HiddenBy != nil {
		res.HiddenBy = transformUserToIncidentviewsUserView(v.HiddenBy)
	}
	if v.Credentials != nil {
		res.Credentials = make(map[string]*incidentviews.CredentialsView, len(v.Credentials))
		for key, val := range v.Credentials {
			tk := key
			res.Credentials[tk] = transformCredentialsToIncidentviewsCredentialsView(val)
		}
	}

	return res
}

// transformPermissionToIncidentviewsPermissionView builds a value of type
// *incidentviews.PermissionView from a value of type *Permission.
func transformPermissionToIncidentviewsPermissionView(v *Permission) *incidentviews.PermissionView {
	if v == nil {
		return nil
	}
	res := &incidentviews.PermissionView{
		Name:  &v.Name,
		Label: v.Label,
	}
	if v.Resources != nil {
		res.Resources = make([]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = val
		}
	}
	if v.Actions != nil {
		res.Actions = make([]string, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = val
		}
	}

	return res
}

// transformCredentialsToIncidentviewsCredentialsView builds a value of type
// *incidentviews.CredentialsView from a value of type *Credentials.
func transformCredentialsToIncidentviewsCredentialsView(v *Credentials) *incidentviews.CredentialsView {
	if v == nil {
		return nil
	}
	res := &incidentviews.CredentialsView{
		Name:        &v.Name,
		Label:       &v.Label,
		Description: v.Description,
	}
	if v.Schemes != nil {
		res.Schemes = make([]string, len(v.Schemes))
		for i, val := range v.Schemes {
			res.Schemes[i] = val
		}
	}
	if v.Tags != nil {
		res.Tags = make([]*incidentviews.CredentialsTagView, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = transformCredentialsTagToIncidentviewsCredentialsTagView(val)
		}
	}

	return res
}

// transformCredentialsTagToIncidentviewsCredentialsTagView builds a value of
// type *incidentviews.CredentialsTagView from a value of type *CredentialsTag.
func transformCredentialsTagToIncidentviewsCredentialsTagView(v *CredentialsTag) *incidentviews.CredentialsTagView {
	if v == nil {
		return nil
	}
	res := &incidentviews.CredentialsTagView{
		Key:   &v.Key,
		Value: &v.Value,
	}

	return res
}

// transformIncidentviewsEscalationViewToEscalation builds a value of type
// *Escalation from a value of type *incidentviews.EscalationView.
func transformIncidentviewsEscalationViewToEscalation(v *incidentviews.EscalationView) *Escalation {
	if v == nil {
		return nil
	}
	res := &Escalation{
		Status: *v.Status,
		Name:   *v.Name,
	}
	if v.Actions != nil {
		res.Actions = make([]*EscalationAction, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = transformIncidentviewsEscalationActionViewToEscalationAction(val)
		}
	}

	return res
}

// transformIncidentviewsEscalationActionViewToEscalationAction builds a value
// of type *EscalationAction from a value of type
// *incidentviews.EscalationActionView.
func transformIncidentviewsEscalationActionViewToEscalationAction(v *incidentviews.EscalationActionView) *EscalationAction {
	res := &EscalationAction{
		Type:        *v.Type,
		Status:      *v.Status,
		StartedAt:   v.StartedAt,
		FinishedAt:  v.FinishedAt,
		Error:       v.Error,
		ProcessHref: v.ProcessHref,
	}
	if v.ApprovalRequest != nil {
		res.ApprovalRequest = transformIncidentviewsApprovalRequestViewToApprovalRequest(v.ApprovalRequest)
	}

	return res
}

// transformIncidentviewsApprovalRequestViewToApprovalRequest builds a value of
// type *ApprovalRequest from a value of type
// *incidentviews.ApprovalRequestView.
func transformIncidentviewsApprovalRequestViewToApprovalRequest(v *incidentviews.ApprovalRequestView) *ApprovalRequest {
	if v == nil {
		return nil
	}
	res := &ApprovalRequest{
		ID:            *v.ID,
		ProjectID:     *v.ProjectID,
		Href:          *v.Href,
		Label:         v.Label,
		Description:   v.Description,
		CreatedAt:     v.CreatedAt,
		UpdatedAt:     v.UpdatedAt,
		Status:        v.Status,
		ApprovedAt:    v.ApprovedAt,
		DenialComment: v.DenialComment,
		DeniedAt:      v.DeniedAt,
		Kind:          *v.Kind,
	}
	if v.Subject != nil {
		res.Subject = transformIncidentviewsApprovalSubjectToApprovalSubject(v.Subject)
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentviewsParameterViewToParameter(val)
		}
	}
	if v.Options != nil {
		res.Options = make([]*ConfigurationOption, len(v.Options))
		for i, val := range v.Options {
			res.Options[i] = transformIncidentviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if v.ApprovedBy != nil {
		res.ApprovedBy = transformIncidentviewsUserViewToUser(v.ApprovedBy)
	}
	if v.DeniedBy != nil {
		res.DeniedBy = transformIncidentviewsUserViewToUser(v.DeniedBy)
	}

	return res
}

// transformIncidentviewsApprovalSubjectToApprovalSubject builds a value of
// type *ApprovalSubject from a value of type *incidentviews.ApprovalSubject.
func transformIncidentviewsApprovalSubjectToApprovalSubject(v *incidentviews.ApprovalSubject) *ApprovalSubject {
	res := &ApprovalSubject{
		Kind: *v.Kind,
		Href: *v.Href,
	}

	return res
}

// transformEscalationToIncidentviewsEscalationView builds a value of type
// *incidentviews.EscalationView from a value of type *Escalation.
func transformEscalationToIncidentviewsEscalationView(v *Escalation) *incidentviews.EscalationView {
	if v == nil {
		return nil
	}
	res := &incidentviews.EscalationView{
		Status: &v.Status,
		Name:   &v.Name,
	}
	if v.Actions != nil {
		res.Actions = make([]*incidentviews.EscalationActionView, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = transformEscalationActionToIncidentviewsEscalationActionView(val)
		}
	}

	return res
}

// transformEscalationActionToIncidentviewsEscalationActionView builds a value
// of type *incidentviews.EscalationActionView from a value of type
// *EscalationAction.
func transformEscalationActionToIncidentviewsEscalationActionView(v *EscalationAction) *incidentviews.EscalationActionView {
	res := &incidentviews.EscalationActionView{
		Type:        &v.Type,
		Status:      &v.Status,
		StartedAt:   v.StartedAt,
		FinishedAt:  v.FinishedAt,
		Error:       v.Error,
		ProcessHref: v.ProcessHref,
	}
	if v.ApprovalRequest != nil {
		res.ApprovalRequest = transformApprovalRequestToIncidentviewsApprovalRequestView(v.ApprovalRequest)
	}

	return res
}

// transformApprovalRequestToIncidentviewsApprovalRequestView builds a value of
// type *incidentviews.ApprovalRequestView from a value of type
// *ApprovalRequest.
func transformApprovalRequestToIncidentviewsApprovalRequestView(v *ApprovalRequest) *incidentviews.ApprovalRequestView {
	if v == nil {
		return nil
	}
	res := &incidentviews.ApprovalRequestView{
		ID:            &v.ID,
		ProjectID:     &v.ProjectID,
		Href:          &v.Href,
		Label:         v.Label,
		Description:   v.Description,
		CreatedAt:     v.CreatedAt,
		UpdatedAt:     v.UpdatedAt,
		Status:        v.Status,
		ApprovedAt:    v.ApprovedAt,
		DenialComment: v.DenialComment,
		DeniedAt:      v.DeniedAt,
		Kind:          &v.Kind,
	}
	if v.Subject != nil {
		res.Subject = transformApprovalSubjectToIncidentviewsApprovalSubject(v.Subject)
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*incidentviews.ParameterView, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformParameterToIncidentviewsParameterView(val)
		}
	}
	if v.Options != nil {
		res.Options = make([]*incidentviews.ConfigurationOptionView, len(v.Options))
		for i, val := range v.Options {
			res.Options[i] = transformConfigurationOptionToIncidentviewsConfigurationOptionView(val)
		}
	}
	if v.ApprovedBy != nil {
		res.ApprovedBy = transformUserToIncidentviewsUserView(v.ApprovedBy)
	}
	if v.DeniedBy != nil {
		res.DeniedBy = transformUserToIncidentviewsUserView(v.DeniedBy)
	}

	return res
}

// transformApprovalSubjectToIncidentviewsApprovalSubject builds a value of
// type *incidentviews.ApprovalSubject from a value of type *ApprovalSubject.
func transformApprovalSubjectToIncidentviewsApprovalSubject(v *ApprovalSubject) *incidentviews.ApprovalSubject {
	res := &incidentviews.ApprovalSubject{
		Kind: &v.Kind,
		Href: &v.Href,
	}

	return res
}

// transformIncidentviewsResolutionViewToResolution builds a value of type
// *Resolution from a value of type *incidentviews.ResolutionView.
func transformIncidentviewsResolutionViewToResolution(v *incidentviews.ResolutionView) *Resolution {
	if v == nil {
		return nil
	}
	res := &Resolution{
		Status: *v.Status,
		Name:   *v.Name,
	}
	if v.Actions != nil {
		res.Actions = make([]*ResolutionAction, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = transformIncidentviewsResolutionActionViewToResolutionAction(val)
		}
	}

	return res
}

// transformIncidentviewsResolutionActionViewToResolutionAction builds a value
// of type *ResolutionAction from a value of type
// *incidentviews.ResolutionActionView.
func transformIncidentviewsResolutionActionViewToResolutionAction(v *incidentviews.ResolutionActionView) *ResolutionAction {
	res := &ResolutionAction{
		Type:        *v.Type,
		Status:      *v.Status,
		StartedAt:   v.StartedAt,
		FinishedAt:  v.FinishedAt,
		Error:       v.Error,
		ProcessHref: v.ProcessHref,
	}
	if v.ApprovalRequest != nil {
		res.ApprovalRequest = transformIncidentviewsApprovalRequestViewToApprovalRequest(v.ApprovalRequest)
	}

	return res
}

// transformResolutionToIncidentviewsResolutionView builds a value of type
// *incidentviews.ResolutionView from a value of type *Resolution.
func transformResolutionToIncidentviewsResolutionView(v *Resolution) *incidentviews.ResolutionView {
	if v == nil {
		return nil
	}
	res := &incidentviews.ResolutionView{
		Status: &v.Status,
		Name:   &v.Name,
	}
	if v.Actions != nil {
		res.Actions = make([]*incidentviews.ResolutionActionView, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = transformResolutionActionToIncidentviewsResolutionActionView(val)
		}
	}

	return res
}

// transformResolutionActionToIncidentviewsResolutionActionView builds a value
// of type *incidentviews.ResolutionActionView from a value of type
// *ResolutionAction.
func transformResolutionActionToIncidentviewsResolutionActionView(v *ResolutionAction) *incidentviews.ResolutionActionView {
	res := &incidentviews.ResolutionActionView{
		Type:        &v.Type,
		Status:      &v.Status,
		StartedAt:   v.StartedAt,
		FinishedAt:  v.FinishedAt,
		Error:       v.Error,
		ProcessHref: v.ProcessHref,
	}
	if v.ApprovalRequest != nil {
		res.ApprovalRequest = transformApprovalRequestToIncidentviewsApprovalRequestView(v.ApprovalRequest)
	}

	return res
}
