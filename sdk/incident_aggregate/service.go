// Code generated by goa v3.1.3, DO NOT EDIT.
//
// IncidentAggregate service
//
// Command:
// $ goa gen github.com/rightscale/governance/front_service/design -o .

package incidentaggregate

import (
	"context"

	incidentaggregateviews "github.com/flexera-public/policy_sdk/sdk/incident_aggregate/views"
	goa "goa.design/goa/v3/pkg"
	"goa.design/goa/v3/security"
)

// Service is the IncidentAggregate service interface.
type Service interface {
	// Show retrieves the details of an aggregate.
	// The "view" return value must have one of the following views
	//	- "index"
	//	- "default"
	//	- "source"
	Show(context.Context, *ShowPayload) (res *IncidentAggregate, view string, err error)
	// ShowNonCatalog retrieves a list of incidents in the non-catalog policy
	// aggregate. These incidents largely originate from dev/test environments.
	// The "view" return value must have one of the following views
	//	- "index"
	//	- "default"
	ShowNonCatalog(context.Context, *ShowNonCatalogPayload) (res *IncidentAggregateNonCatalog, view string, err error)
	// Index retrieves the list of incident_aggregates in an organization.
	Index(context.Context, *IndexPayload) (res *IncidentAggregateList, err error)
}

// Auther defines the authorization functions to be implemented by the service.
type Auther interface {
	// JWTAuth implements the authorization logic for the JWT security scheme.
	JWTAuth(ctx context.Context, token string, schema *security.JWTScheme) (context.Context, error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "IncidentAggregate"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [3]string{"show", "show_non_catalog", "index"}

// ShowPayload is the payload type of the IncidentAggregate service show method.
type ShowPayload struct {
	// org_id identifies an organization by ID.
	OrgID uint
	// incident_aggregate_id identifies an aggregate by ID.
	IncidentAggregateID string
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// View used to render incident aggregate
	View *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// IncidentAggregate is the result type of the IncidentAggregate service show
// method.
type IncidentAggregate struct {
	// id is the ID of the incident_aggregate, must be unique in the org.
	ID string
	// Org represents a RightScale org and provides some information about the org.
	Org *Org
	// href is the href of the incident_aggregate.
	Href *string
	// policy_aggregate links to key attributes of the applied policy that
	// initiated the incident_aggregate.
	PolicyAggregate *PolicyAggregate
	// The number of incidents across all projects.
	Count           *uint
	IncidentSummary *IncidentSummary
	ActionSummary   *ActionSummary
	// An array of the individual incidents and their statuses.
	Items IncidentAggregateItemCollection
	// created_at is the incident_aggregate creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the incident_aggregate update timestamp in RFC3339 format.
	UpdatedAt *string
	// state represents the current handling status of the incident_aggregate.
	State *string
	// severity defines the severity level of the incident_aggregate.
	Severity *string
	// category is the type categorization of the incident_aggregate.
	Category *string
	// dry_run is a flag used for testing a policy, that determines whether this
	// incident_aggregate should trigger escalation actions.
	DryRun *bool
	// kind is "gov#incident_aggregate".
	Kind string
	// etag is an HTTP ETag for the incident_aggregate.
	Etag string
	// not_modified is a flag used internally that indicates how to encode the HTTP
	// response (i.e. 200 or 304).
	NotModified *string
}

// ShowNonCatalogPayload is the payload type of the IncidentAggregate service
// show_non_catalog method.
type ShowNonCatalogPayload struct {
	// org_id identifies an organization by ID.
	OrgID uint
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// View used to render incident aggregate
	View *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// IncidentAggregateNonCatalog is the result type of the IncidentAggregate
// service show_non_catalog method.
type IncidentAggregateNonCatalog struct {
	// href is the href of the incident_aggregate.
	Href *string
	// policy_aggregate links to key attributes of the policy aggregate that
	// initiated the incident_aggregate.
	PolicyAggregate *PolicyAggregateNonCatalog
	// The number of incidents across all projects.
	Count           *uint
	IncidentSummary *IncidentSummary
	ActionSummary   *ActionSummary
	// An array of the individual incidents and their statuses.
	Items IncidentAggregateNonCatalogItemCollection
	// updated_at is the incident_aggregate update timestamp in RFC3339 format.
	UpdatedAt *string
	// kind is "gov#incident_aggregate_non_catalog".
	Kind string
	// etag is an HTTP ETag for the incident_aggregate.
	Etag string
	// not_modified is a flag used internally that indicates how to encode the HTTP
	// response (i.e. 200 or 304).
	NotModified *string
}

// IndexPayload is the payload type of the IncidentAggregate service index
// method.
type IndexPayload struct {
	// org_id identifies an organization by ID.
	OrgID uint
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// View used to render incident_aggregates
	View *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// IncidentAggregateList is the result type of the IncidentAggregate service
// index method.
type IncidentAggregateList struct {
	// count is the number of incident aggregates in the list.
	Count *uint
	// etag is an HTTP ETag for the incident list.
	Etag string
	// items is the array of incident aggregates.
	Items IncidentAggregateCollection
	// not_modified is a flag used internally that indicates how to encode the HTTP
	// response (i.e. 200 or 304).
	NotModified *string
	// kind is "gov#incident_aggregate_list".
	Kind string
}

// Org represents a RightScale organization.
type Org struct {
	// id is the Org ID
	ID uint
	// name is the organization name
	Name string
}

// PolicyAggregate describes a policy that is applied across an entire
// organization. It contains a collection of any number of individual applied
// policies.
type PolicyAggregate struct {
	// id identifies an policy aggregate by ID.
	ID string
	// name provides a name for this specific application of the policy.
	Name string
	// Org represents a RightScale organization.
	Org *Org
	// href is the href of the policy aggregate.
	Href string
	// incident_aggregate_href is the href of the incident aggregate.
	IncidentAggregateHref *string
	// published_template links to key attributes of the published template from
	// which the policy aggregate originated.
	PublishedTemplate *PublishedTemplate
	// project_ids is a the list of projects in this aggregate. If empty, applies
	// to all projects, minus excluded projects
	ProjectIds []uint
	// excluded_project_ids is a list of projects to exclude form this aggregate.
	ExcludedProjectIds []uint
	// description provides a human readable description for this specific
	// application of the policy.
	Description *string
	// doc_link is a HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// created_by is the RightScale user that applied the policy.
	CreatedBy *User
	// created_at is the policy aggregate creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the policy aggregate update timestamp in RFC3339 format.
	UpdatedAt *string
	// severity defines the severity level of incidents raised from this policy
	// aggregate.
	Severity *string
	// category is the type categorization of the policy aggregate.
	Category *string
	// frequency specifies the frequency with which individual policy evaluations
	// run.
	Frequency *string
	// dry_run is a flag used for testing a policy so that an incident can be
	// raised without performing an action.
	DryRun *bool
	// skip_approvals means that any approval actions will be skipped and all
	// actions automatically run.
	SkipApprovals *bool
	// options lists the configuration options used to parameterize the policy.
	Options []*ConfigurationOption
	// credentials is the map of name to credential used to launch the policy.
	Credentials map[string]string
	// status is used to identify the current status of the policy aggregate.
	Status *string
	// running_project_ids is a the list of projects the policy aggregate is
	// currently running on.
	RunningProjectIds []uint
	// The number of applied policies running across all projects.
	Count *uint
	// The number of applied policies in an active state.
	ActiveCount *uint
	// The number of applied policies in an error state.
	ErrorCount *uint
	// errors captures the errors occurred while applying aggregate to individual
	// projects.
	Errors map[string]string
	// An array of the individual applied policies and their statuses.
	Items PolicyAggregateItemCollection
	// kind is "gov#policy_aggregate".
	Kind string
}

// PublishedTemplate describes a previously created published template.
type PublishedTemplate struct {
	// id identifies a published template by ID.
	ID string
	// name is the unique name of the published template in the organization.
	Name string
	// org_id is the ID of the organization that the published template belongs to.
	OrgID *uint
	// project_id is the ID of the project that the published template is published
	// from.
	ProjectID *uint
	// policy_template_id is the ID of the policy template from which the published
	// template originated.
	PolicyTemplateID *string
	// policy_template_url is the full URL to the policy template from which the
	// published template originated.
	PolicyTemplateURL *string
	// policy_template_fingerprint is fingerprint of the policy template. It is
	// used to determine if the policy template that this was published from is
	// outdated.
	PolicyTemplateFingerprint *string
	// rs_pt_ver is the policy engine version.
	RsPtVer *uint
	// short_description is the short description of the published template.
	ShortDescription *string
	// long_description is the long description of the published template. The
	// content can be markdown.
	LongDescription *string
	// doc_link is a HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// default_frequency defines the interval the template will be run unless set
	// differently during application.
	DefaultFrequency *string
	// href is the self-referential href of the published template.
	Href string
	// filename is the name of the file that was uploaded to create the policy
	// template.
	Filename *string
	// source is published template source code.
	Source *string
	// fingerprint is a SHA created during compilation. It is used to determine if
	// the policy template that this was published from is outdated.
	Fingerprint string
	// category is the type categorization of the published template.
	Category *string
	// created_by is the RightScale user that created the published template.
	CreatedBy *User
	// created_at is the published template creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_by is the RightScale user that updated the published template.
	UpdatedBy *User
	// updated_at is the published template update timestamp in RFC3339 format.
	UpdatedAt *string
	// permissions is a list of permissions required to run the policy.
	Permissions map[string]*Permission
	// required_roles is a list of governance roles, derived from permissions,
	// required to run the policy.
	RequiredRoles []string
	// parameters is a list of parameters required to apply the policy.
	Parameters map[string]*Parameter
	// severity defines the severity level of incidents raised from this published
	// template.
	Severity *string
	// built_in is a flag to indicate whether the published template is a
	// "built-in" RS-supplied template.
	BuiltIn *bool
	// hidden is a flag to indicate whether the published template is hidden.
	Hidden *bool
	// hidden_by is the RightScale user that marked the published template as
	// hidden.
	HiddenBy *User
	// hidden_at is the hidden at timestamp in RFC3339 format.
	HiddenAt *string
	// tenancy indicates whether this template can be run across multiple projects
	// or is restricted to a single project.
	Tenancy *string
	// credentials is a list of authorization for external APIs needed to run the
	// policy.
	Credentials map[string]*Credentials
	// kind is "gov#published_template".
	Kind string
}

// User represents a registered RightScale user.
type User struct {
	// ID of user
	ID uint
	// email of user
	Email string
	// name of user, usually of the form 'First Last'
	Name string
}

// Permission defines a role required in RightScale to perform actions on
// resources
type Permission struct {
	// Name of a permission
	Name string `json:"name"`
	// Label is used in the UI
	Label *string `json:"label"`
	// List of resource names the permission is applied to
	Resources []string `json:"resources"`
	// List of action names the permission is applied to
	Actions []string `json:"actions"`
}

// Parameter defines a parameter given as input to a Policy
type Parameter struct {
	// Name of the parameter
	Name string `json:"name"`
	// Type of the parameter
	Type string `json:"type"`
	// Label to show in the UI
	Label string `json:"label"`
	// The index of this parameter in the list
	Index uint `json:"index"`
	// The category used to group parameters
	Category *string `json:"category"`
	// Description of the parameter
	Description *string `json:"description"`
	// The default value for the parameter
	Default interface{} `json:"default"`
	// no_echo determines whether the value of the parameter should be hidden in
	// UIs and API responses.
	NoEcho bool `json:"no_echo"`
	// List of values allowed for this parameter
	AllowedValues []interface{} `json:"allowed_values"`
	// The minimum length of a string parameter
	MinLength *uint `json:"min_length"`
	// The maximum length of a string parameter
	MaxLength *uint `json:"max_length"`
	// The minimum value of a number parmameter
	MinValue *float64 `json:"min_value"`
	// The maximum value of a number parameter
	MaxValue *float64 `json:"max_value"`
	// The regular expression pattern used to validate a string parameter
	AllowedPattern *Regexp `json:"allowed_pattern"`
	// The description used for constraints
	ConstraintDescription *string `json:"constraint_description"`
}

// Regular expression
type Regexp struct {
	// Pattern is the regular expression pattern.
	Pattern string `json:"pattern"`
	// Options are the regular expression options. Options i (case insensitve) and
	// m (match over newlines) supported.
	Options *string `json:"options"`
}

// Credentials describes a reference to an API signer in the credentials
// service in the policy language.
type Credentials struct {
	// Name in policy template source code
	Name string `json:"name"`
	// Schemes of credentials service resource supported.
	Schemes []string `json:"schemes"`
	// Label for the auth reference
	Label string `json:"label"`
	// Description of what types of permissions need to be provided by auth.
	Description *string `json:"description"`
	// Tags is an optional filter to only show credentials matching a certain tag.
	Tags []*CredentialsTag `json:"tags"`
}

type CredentialsTag struct {
	// Key is the tag key.
	Key string `json:"key"`
	// Value is the tag value.
	Value string `json:"value"`
}

// ConfigurationOption describes a single parameter value used to configure an
// applied policy.
type ConfigurationOption struct {
	// name of option
	Name string
	// label of option
	Label string
	// type of option
	Type string
	// value of option
	Value interface{}
	// no_echo determines whether the value of the configuration option should be
	// hidden in UIs and API responses.
	NoEcho bool
}

type PolicyAggregateItemCollection []*PolicyAggregateItem

// PolicyAggregateItem is a summarized view of a running applied policy.
type PolicyAggregateItem struct {
	// id identifies an applied policy by ID.
	ID string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// url of the applied policy.
	URL string
	// created_at is the applied policy creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the applied policy update timestamp in RFC3339 format.
	UpdatedAt *string
	// status is used to identify the current status of the applied policy.
	Status *string
	// error is the error message returned if the evaluation failed. On success
	// this attribute is empty.
	Error *string
	// errored_at is the applied policy error timestamp in RFC3339 format. On
	// success this attribute is empty.
	ErroredAt *string
	// kind is "gov#policy_aggregate_item".
	Kind string
}

// Project represents a RightScale project and provides some information about
// the project.
type Project struct {
	// id is the Project ID
	ID uint
	// name is the Project Name
	Name string
	// org_id is the RightScale Organization ID
	OrgID uint
	// org_name is the RightScale Organization Name
	OrgName string
}

// Summary of all incidents for an incident aggregate.
type IncidentSummary struct {
	// The number of incidents across all projects.
	IncidentCount uint
	// The number of items in violation data across all incidents.
	ViolationDataCount uint
	// The number of incidents in a resolved state across all projects.
	ResolvedCount uint
	// The number of incidents in a triggered state across all projects.
	TriggeredCount uint
}

// Summary of escalation and resolution actions for an incident aggregate.
type ActionSummary struct {
	// The number of incidents with pending approvals.
	PendingCount uint
	// The number of failed escalations.
	FailedCount uint
}

type IncidentAggregateItemCollection []*IncidentAggregateItem

// IncidentAggregateItem describes an incident raised from an applied policy.
type IncidentAggregateItem struct {
	// id is the ID of the incident, must be unique in the project.
	ID string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// url of the incident.
	URL string
	// The number of items in violation data.
	ViolationDataCount *uint
	// created_at is the incident creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the incident update timestamp in RFC3339 format.
	UpdatedAt *string
	// resolved_at is the incident resolution timestamp in RFC3339 format.
	ResolvedAt *string
	// resolved_by is the RightScale user that resolved the incident if it was
	// resolved manually.
	ResolvedBy *User
	// resolution_message is an optional explaination of why the incident is
	// resolved.
	ResolutionMessage *string
	// state represents the current handling status of the incident.
	State *string
	// action_failed indicates whether any of the incident's actions failed during
	// execution.
	ActionFailed *bool
	// action_pending indicates whether any of the incident has any pending actions
	// such as approval requests.
	ActionPending *bool
	// kind is "gov#incident_aggregate_item".
	Kind string
}

// PolicyAggregateNonCatalog is a collection of all other applied policies that
// are not part of an aggregate. Only applied policies that are applied from
// the PolicyTemplate endpoint fall into this category. These types of policies
// shoudl largely be restricted to dev/test policies.
type PolicyAggregateNonCatalog struct {
	// href is the href of the policy aggregate.
	Href string
	// incident_aggregate_href is the href of the incident aggregate.
	IncidentAggregateHref *string
	// running_project_ids is a the list of projects the policy aggregate is
	// currently running on.
	RunningProjectIds []uint
	// The number of applied policies running across all projects.
	Count *uint
	// The number of applied policies in an active state.
	ActiveCount *uint
	// The number of applied policies in an error state.
	ErrorCount *uint
	// An array of the individual applied policies and their statuses.
	Items PolicyAggregateNonCatalogItemCollection
	// kind is "gov#policy_aggregate_non_catalog".
	Kind string
}

type PolicyAggregateNonCatalogItemCollection []*PolicyAggregateNonCatalogItem

// PolicyAggregateNonCatalogItem is a summarized view of a running applied
// policy.
type PolicyAggregateNonCatalogItem struct {
	// id identifies an applied policy by ID.
	ID string
	// name provides a name for this specific application of the policy.
	Name *string
	// description provides a human readable description for this specific
	// application of the policy.
	Description *string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// url of the applied policy.
	URL string
	// policy_template links to key attributes of the template from which the item
	// originated.
	PolicyTemplate *PolicyTemplate
	// status is used to identify the current status of the applied policy.
	Status *string
	// error is the error message returned if the evaluation failed. On success
	// this attribute is empty.
	Error *string
	// errored_at is the applied policy error timestamp in RFC3339 format. On
	// success this attribute is empty.
	ErroredAt *string
	// created_by is the RightScale user that applied the policy.
	CreatedBy *User
	// created_at is the policy aggregate creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the policy aggregate update timestamp in RFC3339 format.
	UpdatedAt *string
	// severity defines the severity level of incidents raised from this policy
	// aggregate.
	Severity *string
	// category is the type categorization of the policy aggregate.
	Category *string
	// frequency specifies the frequency with which individual policy evaluations
	// run.
	Frequency *string
	// dry_run is a flag used for testing a policy so that an incident can be
	// raised without performing an action.
	DryRun *bool
	// kind is "gov#policy_aggregate_non_catalog_item".
	Kind string
}

// PolicyTemplate describes a previously uploaded policy template.
type PolicyTemplate struct {
	// id identifies a policy template by ID.
	ID string
	// name is the unique name of the policy template in the project.
	Name string
	// project_id is the ID of the project that the policy template applies to.
	ProjectID *uint
	// rs_pt_ver is the policy engine version.
	RsPtVer *uint
	// short_description is the short description of the policy template.
	ShortDescription *string
	// long_description is the long description of the policy template. The content
	// can be markdown.
	LongDescription *string
	// doc_link is an HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// default_frequency defines the interval the template will be run unless set
	// differently during application.
	DefaultFrequency *string
	// href is the href of the policy template.
	Href string
	// filename is the name of the file that was uploaded to create the policy
	// template.
	Filename *string
	// source is the policy template source code.
	Source *string
	// fingerprint is a SHA created during compilation. It is used to determine if
	// the template is outdated.
	Fingerprint string
	// category is the type categorization of the policy template.
	Category *string
	// created_by is the RightScale user that created the policy template.
	CreatedBy *User
	// created_at is the policy template creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_by is the RightScale user that updated the policy template.
	UpdatedBy *User
	// updated_at is the last update timestamp in RFC3339 format.
	UpdatedAt *string
	// permissions is a list of permissions required to run the policy.
	Permissions map[string]*Permission
	// required_roles is a list of governance roles, derived from permissions,
	// required to run the policy.
	RequiredRoles []string
	// parameters is a list of parameters required to apply the policy.
	Parameters map[string]*Parameter
	// severity defines the severity level of incidents raised from this policy
	// template.
	Severity *string
	// tenancy indicates whether this template can be run across multiple projects
	// or is restricted to a single project.
	Tenancy *string
	// credentials is a list of authorization for external APIs needed to run the
	// policy.
	Credentials map[string]*Credentials
	// kind is "gov#policy_template".
	Kind string
}

type IncidentAggregateNonCatalogItemCollection []*IncidentAggregateNonCatalogItem

// IncidentAggregateNonCatalogItem describes an incident raised from an applied
// policy.
type IncidentAggregateNonCatalogItem struct {
	// id is the ID of the incident, must be unique in the project.
	ID string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// url of the incident.
	URL string
	// applied_policy links to key attributes of the applied policy that initiated
	// the incident.
	AppliedPolicy *AppliedPolicy
	// The number of items in violation data.
	ViolationDataCount *uint
	// created_at is the incident creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the incident update timestamp in RFC3339 format.
	UpdatedAt *string
	// resolved_at is the incident resolution timestamp in RFC3339 format.
	ResolvedAt *string
	// resolved_by is the RightScale user that resolved the incident if it was
	// resolved manually.
	ResolvedBy *User
	// resolution_message is an optional explaination of why the incident is
	// resolved.
	ResolutionMessage *string
	// state represents the current handling status of the incident.
	State *string
	// action_failed indicates whether any of the incident's actions failed during
	// execution.
	ActionFailed *bool
	// action_pending indicates whether any of the incident has any pending actions
	// such as approval requests.
	ActionPending *bool
	// severity defines the severity level of the incident_aggregate.
	Severity *string
	// category is the type categorization of the incident_aggregate.
	Category *string
	// dry_run is a flag used for testing a policy, that determines whether this
	// incident_aggregate should trigger escalation actions.
	DryRun *bool
	// kind is "gov#incident_aggregate_non_catalog_item".
	Kind string
}

// AppliedPolicy describes a policy that is currently applied.
type AppliedPolicy struct {
	// id identifies an applied policy by ID.
	ID string
	// policy_aggregate_id is set if applied policy is part of an policy aggregate.
	PolicyAggregateID *string
	// incident_aggregate_id is set if applied incident is part of an policy
	// aggregate.
	IncidentAggregateID *string
	// name provides a name for this specific application of the policy.
	Name string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// href is the href of the applied policy.
	Href string
	// policy_template links to key attributes of the policy template from which
	// the applied policy originated.
	PolicyTemplate *PolicyTemplate
	// published_template links to key attributes of the published template from
	// which the applied policy originated.
	PublishedTemplate *PublishedTemplate
	// description provides a human readable description for this specific
	// application of the policy.
	Description *string
	// doc_link is a HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// created_by is the RightScale user that applied the policy.
	CreatedBy *User
	// created_at is the applied policy creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the applied policy update timestamp in RFC3339 format.
	UpdatedAt *string
	// severity defines the severity level of incidents raised from this applied
	// policy.
	Severity *string
	// category is the type categorization of the applied policy.
	Category *string
	// frequency specifies the frequency with which to run policy evaluations
	Frequency *string
	// dry_run is a flag used for testing a policy so that an incident can be
	// raised without performing an action.
	DryRun *bool
	// skip_approvals means that any approval actions will be skipped and all
	// actions automatically run.
	SkipApprovals *bool
	// options lists the configuration options used to parameterize the policy.
	Options []*ConfigurationOption
	// credentials map of credentials to use. The key in the map is the credential
	// name from the PolicyTemplate and the value is the credential identifier from
	// the Credentials management page.
	Credentials map[string]string
	// status is used to identify the current status of the applied policy.
	Status *string
	// error is the error message returned if the evaluation failed. On success
	// this attribute is empty.
	Error *string
	// errored_at is the applied policy error timestamp in RFC3339 format. On
	// success this attribute is empty.
	ErroredAt *string
	// scope is whether the policy is managed at an org-wide or project level.
	Scope *string
	// kind is "gov#applied_policy".
	Kind string
}

type IncidentAggregateCollection []*IncidentAggregate

// MakeUnauthorized builds a goa.ServiceError from an error.
func MakeUnauthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unauthorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeForbidden builds a goa.ServiceError from an error.
func MakeForbidden(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "forbidden",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadRequest builds a goa.ServiceError from an error.
func MakeBadRequest(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_request",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadGateway builds a goa.ServiceError from an error.
func MakeBadGateway(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_gateway",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInternalError builds a goa.ServiceError from an error.
func MakeInternalError(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "internal_error",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not_found",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewIncidentAggregate initializes result type IncidentAggregate from viewed
// result type IncidentAggregate.
func NewIncidentAggregate(vres *incidentaggregateviews.IncidentAggregate) *IncidentAggregate {
	var res *IncidentAggregate
	switch vres.View {
	case "index":
		res = newIncidentAggregateIndex(vres.Projected)
	case "default", "":
		res = newIncidentAggregate(vres.Projected)
	case "source":
		res = newIncidentAggregateSource(vres.Projected)
	}
	return res
}

// NewViewedIncidentAggregate initializes viewed result type IncidentAggregate
// from result type IncidentAggregate using the given view.
func NewViewedIncidentAggregate(res *IncidentAggregate, view string) *incidentaggregateviews.IncidentAggregate {
	var vres *incidentaggregateviews.IncidentAggregate
	switch view {
	case "index":
		p := newIncidentAggregateViewIndex(res)
		vres = &incidentaggregateviews.IncidentAggregate{Projected: p, View: "index"}
	case "default", "":
		p := newIncidentAggregateView(res)
		vres = &incidentaggregateviews.IncidentAggregate{Projected: p, View: "default"}
	case "source":
		p := newIncidentAggregateViewSource(res)
		vres = &incidentaggregateviews.IncidentAggregate{Projected: p, View: "source"}
	}
	return vres
}

// NewIncidentAggregateNonCatalog initializes result type
// IncidentAggregateNonCatalog from viewed result type
// IncidentAggregateNonCatalog.
func NewIncidentAggregateNonCatalog(vres *incidentaggregateviews.IncidentAggregateNonCatalog) *IncidentAggregateNonCatalog {
	var res *IncidentAggregateNonCatalog
	switch vres.View {
	case "index":
		res = newIncidentAggregateNonCatalogIndex(vres.Projected)
	case "default", "":
		res = newIncidentAggregateNonCatalog(vres.Projected)
	}
	return res
}

// NewViewedIncidentAggregateNonCatalog initializes viewed result type
// IncidentAggregateNonCatalog from result type IncidentAggregateNonCatalog
// using the given view.
func NewViewedIncidentAggregateNonCatalog(res *IncidentAggregateNonCatalog, view string) *incidentaggregateviews.IncidentAggregateNonCatalog {
	var vres *incidentaggregateviews.IncidentAggregateNonCatalog
	switch view {
	case "index":
		p := newIncidentAggregateNonCatalogViewIndex(res)
		vres = &incidentaggregateviews.IncidentAggregateNonCatalog{Projected: p, View: "index"}
	case "default", "":
		p := newIncidentAggregateNonCatalogView(res)
		vres = &incidentaggregateviews.IncidentAggregateNonCatalog{Projected: p, View: "default"}
	}
	return vres
}

// NewIncidentAggregateList initializes result type IncidentAggregateList from
// viewed result type IncidentAggregateList.
func NewIncidentAggregateList(vres *incidentaggregateviews.IncidentAggregateList) *IncidentAggregateList {
	return newIncidentAggregateList(vres.Projected)
}

// NewViewedIncidentAggregateList initializes viewed result type
// IncidentAggregateList from result type IncidentAggregateList using the given
// view.
func NewViewedIncidentAggregateList(res *IncidentAggregateList, view string) *incidentaggregateviews.IncidentAggregateList {
	p := newIncidentAggregateListView(res)
	return &incidentaggregateviews.IncidentAggregateList{Projected: p, View: "default"}
}

// newIncidentAggregateIndex converts projected type IncidentAggregate to
// service type IncidentAggregate.
func newIncidentAggregateIndex(vres *incidentaggregateviews.IncidentAggregateView) *IncidentAggregate {
	res := &IncidentAggregate{
		Href:        vres.Href,
		CreatedAt:   vres.CreatedAt,
		UpdatedAt:   vres.UpdatedAt,
		Count:       vres.Count,
		State:       vres.State,
		Severity:    vres.Severity,
		Category:    vres.Category,
		DryRun:      vres.DryRun,
		NotModified: vres.NotModified,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Org != nil {
		res.Org = transformIncidentaggregateviewsOrgViewToOrg(vres.Org)
	}
	if vres.ActionSummary != nil {
		res.ActionSummary = transformIncidentaggregateviewsActionSummaryViewToActionSummary(vres.ActionSummary)
	}
	if vres.PolicyAggregate != nil {
		res.PolicyAggregate = newPolicyAggregateLink(vres.PolicyAggregate)
	}
	if vres.IncidentSummary != nil {
		res.IncidentSummary = newIncidentSummary(vres.IncidentSummary)
	}
	if vres.Items != nil {
		res.Items = newIncidentAggregateItemCollection(vres.Items)
	}
	return res
}

// newIncidentAggregate converts projected type IncidentAggregate to service
// type IncidentAggregate.
func newIncidentAggregate(vres *incidentaggregateviews.IncidentAggregateView) *IncidentAggregate {
	res := &IncidentAggregate{
		Href:        vres.Href,
		CreatedAt:   vres.CreatedAt,
		UpdatedAt:   vres.UpdatedAt,
		State:       vres.State,
		Count:       vres.Count,
		Severity:    vres.Severity,
		Category:    vres.Category,
		DryRun:      vres.DryRun,
		NotModified: vres.NotModified,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Org != nil {
		res.Org = transformIncidentaggregateviewsOrgViewToOrg(vres.Org)
	}
	if vres.ActionSummary != nil {
		res.ActionSummary = transformIncidentaggregateviewsActionSummaryViewToActionSummary(vres.ActionSummary)
	}
	if vres.PolicyAggregate != nil {
		res.PolicyAggregate = newPolicyAggregateLink(vres.PolicyAggregate)
	}
	if vres.IncidentSummary != nil {
		res.IncidentSummary = newIncidentSummary(vres.IncidentSummary)
	}
	if vres.Items != nil {
		res.Items = newIncidentAggregateItemCollection(vres.Items)
	}
	return res
}

// newIncidentAggregateSource converts projected type IncidentAggregate to
// service type IncidentAggregate.
func newIncidentAggregateSource(vres *incidentaggregateviews.IncidentAggregateView) *IncidentAggregate {
	res := &IncidentAggregate{
		Href:        vres.Href,
		NotModified: vres.NotModified,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Org != nil {
		res.Org = transformIncidentaggregateviewsOrgViewToOrg(vres.Org)
	}
	if vres.PolicyAggregate != nil {
		res.PolicyAggregate = newPolicyAggregateSource(vres.PolicyAggregate)
	}
	if vres.IncidentSummary != nil {
		res.IncidentSummary = newIncidentSummary(vres.IncidentSummary)
	}
	if vres.Items != nil {
		res.Items = newIncidentAggregateItemCollection(vres.Items)
	}
	return res
}

// newIncidentAggregateViewIndex projects result type IncidentAggregate to
// projected type IncidentAggregateView using the "index" view.
func newIncidentAggregateViewIndex(res *IncidentAggregate) *incidentaggregateviews.IncidentAggregateView {
	vres := &incidentaggregateviews.IncidentAggregateView{
		ID:          &res.ID,
		Href:        res.Href,
		Count:       res.Count,
		CreatedAt:   res.CreatedAt,
		UpdatedAt:   res.UpdatedAt,
		State:       res.State,
		Severity:    res.Severity,
		Category:    res.Category,
		DryRun:      res.DryRun,
		Kind:        &res.Kind,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
	}
	if res.Org != nil {
		vres.Org = transformOrgToIncidentaggregateviewsOrgView(res.Org)
	}
	if res.ActionSummary != nil {
		vres.ActionSummary = transformActionSummaryToIncidentaggregateviewsActionSummaryView(res.ActionSummary)
	}
	if res.PolicyAggregate != nil {
		vres.PolicyAggregate = newPolicyAggregateViewLink(res.PolicyAggregate)
	}
	if res.IncidentSummary != nil {
		vres.IncidentSummary = newIncidentSummaryView(res.IncidentSummary)
	}
	return vres
}

// newIncidentAggregateView projects result type IncidentAggregate to projected
// type IncidentAggregateView using the "default" view.
func newIncidentAggregateView(res *IncidentAggregate) *incidentaggregateviews.IncidentAggregateView {
	vres := &incidentaggregateviews.IncidentAggregateView{
		ID:          &res.ID,
		Href:        res.Href,
		Count:       res.Count,
		CreatedAt:   res.CreatedAt,
		UpdatedAt:   res.UpdatedAt,
		State:       res.State,
		Severity:    res.Severity,
		Category:    res.Category,
		DryRun:      res.DryRun,
		Kind:        &res.Kind,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
	}
	if res.Org != nil {
		vres.Org = transformOrgToIncidentaggregateviewsOrgView(res.Org)
	}
	if res.IncidentSummary != nil {
		vres.IncidentSummary = transformIncidentSummaryToIncidentaggregateviewsIncidentSummaryView(res.IncidentSummary)
	}
	if res.PolicyAggregate != nil {
		vres.PolicyAggregate = newPolicyAggregateViewLink(res.PolicyAggregate)
	}
	if res.Items != nil {
		vres.Items = newIncidentAggregateItemCollectionView(res.Items)
	}
	if res.ActionSummary != nil {
		vres.ActionSummary = newActionSummaryView(res.ActionSummary)
	}
	return vres
}

// newIncidentAggregateViewSource projects result type IncidentAggregate to
// projected type IncidentAggregateView using the "source" view.
func newIncidentAggregateViewSource(res *IncidentAggregate) *incidentaggregateviews.IncidentAggregateView {
	vres := &incidentaggregateviews.IncidentAggregateView{
		ID:          &res.ID,
		Href:        res.Href,
		Kind:        &res.Kind,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
	}
	if res.Org != nil {
		vres.Org = transformOrgToIncidentaggregateviewsOrgView(res.Org)
	}
	if res.PolicyAggregate != nil {
		vres.PolicyAggregate = newPolicyAggregateViewSource(res.PolicyAggregate)
	}
	return vres
}

// newPolicyAggregate converts projected type PolicyAggregate to service type
// PolicyAggregate.
func newPolicyAggregate(vres *incidentaggregateviews.PolicyAggregateView) *PolicyAggregate {
	res := &PolicyAggregate{
		IncidentAggregateHref: vres.IncidentAggregateHref,
		Description:           vres.Description,
		DocLink:               vres.DocLink,
		CreatedAt:             vres.CreatedAt,
		UpdatedAt:             vres.UpdatedAt,
		Severity:              vres.Severity,
		Category:              vres.Category,
		Frequency:             vres.Frequency,
		DryRun:                vres.DryRun,
		SkipApprovals:         vres.SkipApprovals,
		Status:                vres.Status,
		Count:                 vres.Count,
		ActiveCount:           vres.ActiveCount,
		ErrorCount:            vres.ErrorCount,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Org != nil {
		res.Org = transformIncidentaggregateviewsOrgViewToOrg(vres.Org)
	}
	if vres.ProjectIds != nil {
		res.ProjectIds = make([]uint, len(vres.ProjectIds))
		for i, val := range vres.ProjectIds {
			res.ProjectIds[i] = val
		}
	}
	if vres.ExcludedProjectIds != nil {
		res.ExcludedProjectIds = make([]uint, len(vres.ExcludedProjectIds))
		for i, val := range vres.ExcludedProjectIds {
			res.ExcludedProjectIds[i] = val
		}
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = transformIncidentaggregateviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]string, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			tv := val
			res.Credentials[tk] = tv
		}
	}
	if vres.RunningProjectIds != nil {
		res.RunningProjectIds = make([]uint, len(vres.RunningProjectIds))
		for i, val := range vres.RunningProjectIds {
			res.RunningProjectIds[i] = val
		}
	}
	if vres.Errors != nil {
		res.Errors = make(map[string]string, len(vres.Errors))
		for key, val := range vres.Errors {
			tk := key
			tv := val
			res.Errors[tk] = tv
		}
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = newPublishedTemplateLink(vres.PublishedTemplate)
	}
	if vres.Items != nil {
		res.Items = newPolicyAggregateItemCollection(vres.Items)
	}
	return res
}

// newPolicyAggregateIndex converts projected type PolicyAggregate to service
// type PolicyAggregate.
func newPolicyAggregateIndex(vres *incidentaggregateviews.PolicyAggregateView) *PolicyAggregate {
	res := &PolicyAggregate{
		IncidentAggregateHref: vres.IncidentAggregateHref,
		Description:           vres.Description,
		DocLink:               vres.DocLink,
		CreatedAt:             vres.CreatedAt,
		UpdatedAt:             vres.UpdatedAt,
		Severity:              vres.Severity,
		Category:              vres.Category,
		Frequency:             vres.Frequency,
		DryRun:                vres.DryRun,
		SkipApprovals:         vres.SkipApprovals,
		Status:                vres.Status,
		Count:                 vres.Count,
		ActiveCount:           vres.ActiveCount,
		ErrorCount:            vres.ErrorCount,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Org != nil {
		res.Org = transformIncidentaggregateviewsOrgViewToOrg(vres.Org)
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = transformIncidentaggregateviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]string, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			tv := val
			res.Credentials[tk] = tv
		}
	}
	if vres.RunningProjectIds != nil {
		res.RunningProjectIds = make([]uint, len(vres.RunningProjectIds))
		for i, val := range vres.RunningProjectIds {
			res.RunningProjectIds[i] = val
		}
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = newPublishedTemplateLink(vres.PublishedTemplate)
	}
	if vres.Items != nil {
		res.Items = newPolicyAggregateItemCollection(vres.Items)
	}
	return res
}

// newPolicyAggregateSource converts projected type PolicyAggregate to service
// type PolicyAggregate.
func newPolicyAggregateSource(vres *incidentaggregateviews.PolicyAggregateView) *PolicyAggregate {
	res := &PolicyAggregate{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Org != nil {
		res.Org = transformIncidentaggregateviewsOrgViewToOrg(vres.Org)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = newPublishedTemplateSource(vres.PublishedTemplate)
	}
	if vres.Items != nil {
		res.Items = newPolicyAggregateItemCollection(vres.Items)
	}
	return res
}

// newPolicyAggregateLink converts projected type PolicyAggregate to service
// type PolicyAggregate.
func newPolicyAggregateLink(vres *incidentaggregateviews.PolicyAggregateView) *PolicyAggregate {
	res := &PolicyAggregate{
		IncidentAggregateHref: vres.IncidentAggregateHref,
		CreatedAt:             vres.CreatedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = newPublishedTemplateLink(vres.PublishedTemplate)
	}
	if vres.Items != nil {
		res.Items = newPolicyAggregateItemCollection(vres.Items)
	}
	return res
}

// newPolicyAggregateView projects result type PolicyAggregate to projected
// type PolicyAggregateView using the "default" view.
func newPolicyAggregateView(res *PolicyAggregate) *incidentaggregateviews.PolicyAggregateView {
	vres := &incidentaggregateviews.PolicyAggregateView{
		ID:                    &res.ID,
		Name:                  &res.Name,
		Href:                  &res.Href,
		IncidentAggregateHref: res.IncidentAggregateHref,
		Description:           res.Description,
		DocLink:               res.DocLink,
		CreatedAt:             res.CreatedAt,
		UpdatedAt:             res.UpdatedAt,
		Severity:              res.Severity,
		Category:              res.Category,
		Frequency:             res.Frequency,
		DryRun:                res.DryRun,
		SkipApprovals:         res.SkipApprovals,
		Status:                res.Status,
		Count:                 res.Count,
		ActiveCount:           res.ActiveCount,
		ErrorCount:            res.ErrorCount,
		Kind:                  &res.Kind,
	}
	if res.Org != nil {
		vres.Org = transformOrgToIncidentaggregateviewsOrgView(res.Org)
	}
	if res.ProjectIds != nil {
		vres.ProjectIds = make([]uint, len(res.ProjectIds))
		for i, val := range res.ProjectIds {
			vres.ProjectIds[i] = val
		}
	}
	if res.ExcludedProjectIds != nil {
		vres.ExcludedProjectIds = make([]uint, len(res.ExcludedProjectIds))
		for i, val := range res.ExcludedProjectIds {
			vres.ExcludedProjectIds[i] = val
		}
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.Options != nil {
		vres.Options = make([]*incidentaggregateviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = transformConfigurationOptionToIncidentaggregateviewsConfigurationOptionView(val)
		}
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]string, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			tv := val
			vres.Credentials[tk] = tv
		}
	}
	if res.RunningProjectIds != nil {
		vres.RunningProjectIds = make([]uint, len(res.RunningProjectIds))
		for i, val := range res.RunningProjectIds {
			vres.RunningProjectIds[i] = val
		}
	}
	if res.Errors != nil {
		vres.Errors = make(map[string]string, len(res.Errors))
		for key, val := range res.Errors {
			tk := key
			tv := val
			vres.Errors[tk] = tv
		}
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = newPublishedTemplateViewLink(res.PublishedTemplate)
	}
	if res.Items != nil {
		vres.Items = newPolicyAggregateItemCollectionView(res.Items)
	}
	return vres
}

// newPolicyAggregateViewIndex projects result type PolicyAggregate to
// projected type PolicyAggregateView using the "index" view.
func newPolicyAggregateViewIndex(res *PolicyAggregate) *incidentaggregateviews.PolicyAggregateView {
	vres := &incidentaggregateviews.PolicyAggregateView{
		ID:                    &res.ID,
		Name:                  &res.Name,
		Href:                  &res.Href,
		IncidentAggregateHref: res.IncidentAggregateHref,
		Description:           res.Description,
		DocLink:               res.DocLink,
		CreatedAt:             res.CreatedAt,
		UpdatedAt:             res.UpdatedAt,
		Severity:              res.Severity,
		Category:              res.Category,
		Frequency:             res.Frequency,
		DryRun:                res.DryRun,
		SkipApprovals:         res.SkipApprovals,
		Status:                res.Status,
		Count:                 res.Count,
		ActiveCount:           res.ActiveCount,
		ErrorCount:            res.ErrorCount,
		Kind:                  &res.Kind,
	}
	if res.Org != nil {
		vres.Org = transformOrgToIncidentaggregateviewsOrgView(res.Org)
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.Options != nil {
		vres.Options = make([]*incidentaggregateviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = transformConfigurationOptionToIncidentaggregateviewsConfigurationOptionView(val)
		}
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]string, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			tv := val
			vres.Credentials[tk] = tv
		}
	}
	if res.RunningProjectIds != nil {
		vres.RunningProjectIds = make([]uint, len(res.RunningProjectIds))
		for i, val := range res.RunningProjectIds {
			vres.RunningProjectIds[i] = val
		}
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = newPublishedTemplateViewLink(res.PublishedTemplate)
	}
	return vres
}

// newPolicyAggregateViewSource projects result type PolicyAggregate to
// projected type PolicyAggregateView using the "source" view.
func newPolicyAggregateViewSource(res *PolicyAggregate) *incidentaggregateviews.PolicyAggregateView {
	vres := &incidentaggregateviews.PolicyAggregateView{
		ID:   &res.ID,
		Name: &res.Name,
		Href: &res.Href,
		Kind: &res.Kind,
	}
	if res.Org != nil {
		vres.Org = transformOrgToIncidentaggregateviewsOrgView(res.Org)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = newPublishedTemplateViewSource(res.PublishedTemplate)
	}
	return vres
}

// newPolicyAggregateViewLink projects result type PolicyAggregate to projected
// type PolicyAggregateView using the "link" view.
func newPolicyAggregateViewLink(res *PolicyAggregate) *incidentaggregateviews.PolicyAggregateView {
	vres := &incidentaggregateviews.PolicyAggregateView{
		ID:                    &res.ID,
		Name:                  &res.Name,
		Href:                  &res.Href,
		IncidentAggregateHref: res.IncidentAggregateHref,
		CreatedAt:             res.CreatedAt,
		Kind:                  &res.Kind,
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = newPublishedTemplateViewLink(res.PublishedTemplate)
	}
	return vres
}

// newPublishedTemplate converts projected type PublishedTemplate to service
// type PublishedTemplate.
func newPublishedTemplate(vres *incidentaggregateviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		OrgID:                     vres.OrgID,
		ProjectID:                 vres.ProjectID,
		PolicyTemplateID:          vres.PolicyTemplateID,
		PolicyTemplateURL:         vres.PolicyTemplateURL,
		PolicyTemplateFingerprint: vres.PolicyTemplateFingerprint,
		RsPtVer:                   vres.RsPtVer,
		ShortDescription:          vres.ShortDescription,
		DocLink:                   vres.DocLink,
		DefaultFrequency:          vres.DefaultFrequency,
		Category:                  vres.Category,
		CreatedAt:                 vres.CreatedAt,
		UpdatedAt:                 vres.UpdatedAt,
		HiddenAt:                  vres.HiddenAt,
		Severity:                  vres.Severity,
		BuiltIn:                   vres.BuiltIn,
		Hidden:                    vres.Hidden,
		Tenancy:                   vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentaggregateviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.HiddenBy != nil {
		res.HiddenBy = transformIncidentaggregateviewsUserViewToUser(vres.HiddenBy)
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	return res
}

// newPublishedTemplateExtended converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateExtended(vres *incidentaggregateviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		OrgID:                     vres.OrgID,
		ProjectID:                 vres.ProjectID,
		PolicyTemplateID:          vres.PolicyTemplateID,
		PolicyTemplateURL:         vres.PolicyTemplateURL,
		PolicyTemplateFingerprint: vres.PolicyTemplateFingerprint,
		RsPtVer:                   vres.RsPtVer,
		ShortDescription:          vres.ShortDescription,
		LongDescription:           vres.LongDescription,
		DocLink:                   vres.DocLink,
		DefaultFrequency:          vres.DefaultFrequency,
		Category:                  vres.Category,
		CreatedAt:                 vres.CreatedAt,
		UpdatedAt:                 vres.UpdatedAt,
		HiddenAt:                  vres.HiddenAt,
		Severity:                  vres.Severity,
		BuiltIn:                   vres.BuiltIn,
		Hidden:                    vres.Hidden,
		Tenancy:                   vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentaggregateviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.HiddenBy != nil {
		res.HiddenBy = transformIncidentaggregateviewsUserViewToUser(vres.HiddenBy)
	}
	if vres.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(vres.Permissions))
		for key, val := range vres.Permissions {
			tk := key
			res.Permissions[tk] = transformIncidentaggregateviewsPermissionViewToPermission(val)
		}
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentaggregateviewsParameterViewToParameter(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]*Credentials, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			res.Credentials[tk] = transformIncidentaggregateviewsCredentialsViewToCredentials(val)
		}
	}
	return res
}

// newPublishedTemplateSource converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateSource(vres *incidentaggregateviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		Filename: vres.Filename,
		Source:   vres.Source,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	return res
}

// newPublishedTemplateLink converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateLink(vres *incidentaggregateviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		UpdatedAt: vres.UpdatedAt,
		BuiltIn:   vres.BuiltIn,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentaggregateviewsUserViewToUser(vres.UpdatedBy)
	}
	return res
}

// newPublishedTemplateView projects result type PublishedTemplate to projected
// type PublishedTemplateView using the "default" view.
func newPublishedTemplateView(res *PublishedTemplate) *incidentaggregateviews.PublishedTemplateView {
	vres := &incidentaggregateviews.PublishedTemplateView{
		ID:                        &res.ID,
		Name:                      &res.Name,
		OrgID:                     res.OrgID,
		ProjectID:                 res.ProjectID,
		PolicyTemplateID:          res.PolicyTemplateID,
		PolicyTemplateURL:         res.PolicyTemplateURL,
		PolicyTemplateFingerprint: res.PolicyTemplateFingerprint,
		RsPtVer:                   res.RsPtVer,
		ShortDescription:          res.ShortDescription,
		DocLink:                   res.DocLink,
		DefaultFrequency:          res.DefaultFrequency,
		Href:                      &res.Href,
		Fingerprint:               &res.Fingerprint,
		Category:                  res.Category,
		CreatedAt:                 res.CreatedAt,
		UpdatedAt:                 res.UpdatedAt,
		Severity:                  res.Severity,
		BuiltIn:                   res.BuiltIn,
		Hidden:                    res.Hidden,
		HiddenAt:                  res.HiddenAt,
		Tenancy:                   res.Tenancy,
		Kind:                      &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentaggregateviewsUserView(res.UpdatedBy)
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.HiddenBy != nil {
		vres.HiddenBy = transformUserToIncidentaggregateviewsUserView(res.HiddenBy)
	}
	return vres
}

// newPublishedTemplateViewExtended projects result type PublishedTemplate to
// projected type PublishedTemplateView using the "extended" view.
func newPublishedTemplateViewExtended(res *PublishedTemplate) *incidentaggregateviews.PublishedTemplateView {
	vres := &incidentaggregateviews.PublishedTemplateView{
		ID:                        &res.ID,
		Name:                      &res.Name,
		OrgID:                     res.OrgID,
		ProjectID:                 res.ProjectID,
		PolicyTemplateID:          res.PolicyTemplateID,
		PolicyTemplateURL:         res.PolicyTemplateURL,
		PolicyTemplateFingerprint: res.PolicyTemplateFingerprint,
		RsPtVer:                   res.RsPtVer,
		ShortDescription:          res.ShortDescription,
		LongDescription:           res.LongDescription,
		DocLink:                   res.DocLink,
		DefaultFrequency:          res.DefaultFrequency,
		Href:                      &res.Href,
		Fingerprint:               &res.Fingerprint,
		Category:                  res.Category,
		CreatedAt:                 res.CreatedAt,
		UpdatedAt:                 res.UpdatedAt,
		Severity:                  res.Severity,
		BuiltIn:                   res.BuiltIn,
		Hidden:                    res.Hidden,
		HiddenAt:                  res.HiddenAt,
		Tenancy:                   res.Tenancy,
		Kind:                      &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentaggregateviewsUserView(res.UpdatedBy)
	}
	if res.Permissions != nil {
		vres.Permissions = make(map[string]*incidentaggregateviews.PermissionView, len(res.Permissions))
		for key, val := range res.Permissions {
			tk := key
			vres.Permissions[tk] = transformPermissionToIncidentaggregateviewsPermissionView(val)
		}
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*incidentaggregateviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			vres.Parameters[tk] = transformParameterToIncidentaggregateviewsParameterView(val)
		}
	}
	if res.HiddenBy != nil {
		vres.HiddenBy = transformUserToIncidentaggregateviewsUserView(res.HiddenBy)
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]*incidentaggregateviews.CredentialsView, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			vres.Credentials[tk] = transformCredentialsToIncidentaggregateviewsCredentialsView(val)
		}
	}
	return vres
}

// newPublishedTemplateViewSource projects result type PublishedTemplate to
// projected type PublishedTemplateView using the "source" view.
func newPublishedTemplateViewSource(res *PublishedTemplate) *incidentaggregateviews.PublishedTemplateView {
	vres := &incidentaggregateviews.PublishedTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Filename:    res.Filename,
		Source:      res.Source,
		Fingerprint: &res.Fingerprint,
		Kind:        &res.Kind,
	}
	return vres
}

// newPublishedTemplateViewLink projects result type PublishedTemplate to
// projected type PublishedTemplateView using the "link" view.
func newPublishedTemplateViewLink(res *PublishedTemplate) *incidentaggregateviews.PublishedTemplateView {
	vres := &incidentaggregateviews.PublishedTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Fingerprint: &res.Fingerprint,
		UpdatedAt:   res.UpdatedAt,
		BuiltIn:     res.BuiltIn,
		Kind:        &res.Kind,
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentaggregateviewsUserView(res.UpdatedBy)
	}
	return vres
}

// newPolicyAggregateItemCollection converts projected type
// PolicyAggregateItemCollection to service type PolicyAggregateItemCollection.
func newPolicyAggregateItemCollection(vres incidentaggregateviews.PolicyAggregateItemCollectionView) PolicyAggregateItemCollection {
	res := make(PolicyAggregateItemCollection, len(vres))
	for i, n := range vres {
		res[i] = newPolicyAggregateItem(n)
	}
	return res
}

// newPolicyAggregateItemCollectionLink converts projected type
// PolicyAggregateItemCollection to service type PolicyAggregateItemCollection.
func newPolicyAggregateItemCollectionLink(vres incidentaggregateviews.PolicyAggregateItemCollectionView) PolicyAggregateItemCollection {
	res := make(PolicyAggregateItemCollection, len(vres))
	for i, n := range vres {
		res[i] = newPolicyAggregateItemLink(n)
	}
	return res
}

// newPolicyAggregateItemCollectionView projects result type
// PolicyAggregateItemCollection to projected type
// PolicyAggregateItemCollectionView using the "default" view.
func newPolicyAggregateItemCollectionView(res PolicyAggregateItemCollection) incidentaggregateviews.PolicyAggregateItemCollectionView {
	vres := make(incidentaggregateviews.PolicyAggregateItemCollectionView, len(res))
	for i, n := range res {
		vres[i] = newPolicyAggregateItemView(n)
	}
	return vres
}

// newPolicyAggregateItemCollectionViewLink projects result type
// PolicyAggregateItemCollection to projected type
// PolicyAggregateItemCollectionView using the "link" view.
func newPolicyAggregateItemCollectionViewLink(res PolicyAggregateItemCollection) incidentaggregateviews.PolicyAggregateItemCollectionView {
	vres := make(incidentaggregateviews.PolicyAggregateItemCollectionView, len(res))
	for i, n := range res {
		vres[i] = newPolicyAggregateItemViewLink(n)
	}
	return vres
}

// newPolicyAggregateItem converts projected type PolicyAggregateItem to
// service type PolicyAggregateItem.
func newPolicyAggregateItem(vres *incidentaggregateviews.PolicyAggregateItemView) *PolicyAggregateItem {
	res := &PolicyAggregateItem{
		CreatedAt: vres.CreatedAt,
		UpdatedAt: vres.UpdatedAt,
		Status:    vres.Status,
		Error:     vres.Error,
		ErroredAt: vres.ErroredAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.URL != nil {
		res.URL = *vres.URL
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentaggregateviewsProjectViewToProject(vres.Project)
	}
	return res
}

// newPolicyAggregateItemLink converts projected type PolicyAggregateItem to
// service type PolicyAggregateItem.
func newPolicyAggregateItemLink(vres *incidentaggregateviews.PolicyAggregateItemView) *PolicyAggregateItem {
	res := &PolicyAggregateItem{
		CreatedAt: vres.CreatedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.URL != nil {
		res.URL = *vres.URL
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	return res
}

// newPolicyAggregateItemView projects result type PolicyAggregateItem to
// projected type PolicyAggregateItemView using the "default" view.
func newPolicyAggregateItemView(res *PolicyAggregateItem) *incidentaggregateviews.PolicyAggregateItemView {
	vres := &incidentaggregateviews.PolicyAggregateItemView{
		ID:        &res.ID,
		URL:       &res.URL,
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
		Status:    res.Status,
		Error:     res.Error,
		ErroredAt: res.ErroredAt,
		Kind:      &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentaggregateviewsProjectView(res.Project)
	}
	return vres
}

// newPolicyAggregateItemViewLink projects result type PolicyAggregateItem to
// projected type PolicyAggregateItemView using the "link" view.
func newPolicyAggregateItemViewLink(res *PolicyAggregateItem) *incidentaggregateviews.PolicyAggregateItemView {
	vres := &incidentaggregateviews.PolicyAggregateItemView{
		ID:        &res.ID,
		URL:       &res.URL,
		CreatedAt: res.CreatedAt,
		Kind:      &res.Kind,
	}
	return vres
}

// newIncidentSummary converts projected type IncidentSummary to service type
// IncidentSummary.
func newIncidentSummary(vres *incidentaggregateviews.IncidentSummaryView) *IncidentSummary {
	res := &IncidentSummary{}
	if vres.IncidentCount != nil {
		res.IncidentCount = *vres.IncidentCount
	}
	if vres.ViolationDataCount != nil {
		res.ViolationDataCount = *vres.ViolationDataCount
	}
	if vres.ResolvedCount != nil {
		res.ResolvedCount = *vres.ResolvedCount
	}
	if vres.TriggeredCount != nil {
		res.TriggeredCount = *vres.TriggeredCount
	}
	return res
}

// newIncidentSummaryView projects result type IncidentSummary to projected
// type IncidentSummaryView using the "default" view.
func newIncidentSummaryView(res *IncidentSummary) *incidentaggregateviews.IncidentSummaryView {
	vres := &incidentaggregateviews.IncidentSummaryView{
		IncidentCount:      &res.IncidentCount,
		ViolationDataCount: &res.ViolationDataCount,
		ResolvedCount:      &res.ResolvedCount,
		TriggeredCount:     &res.TriggeredCount,
	}
	return vres
}

// newActionSummary converts projected type ActionSummary to service type
// ActionSummary.
func newActionSummary(vres *incidentaggregateviews.ActionSummaryView) *ActionSummary {
	res := &ActionSummary{}
	if vres.PendingCount != nil {
		res.PendingCount = *vres.PendingCount
	}
	if vres.FailedCount != nil {
		res.FailedCount = *vres.FailedCount
	}
	return res
}

// newActionSummaryView projects result type ActionSummary to projected type
// ActionSummaryView using the "default" view.
func newActionSummaryView(res *ActionSummary) *incidentaggregateviews.ActionSummaryView {
	vres := &incidentaggregateviews.ActionSummaryView{
		PendingCount: &res.PendingCount,
		FailedCount:  &res.FailedCount,
	}
	return vres
}

// newIncidentAggregateItemCollection converts projected type
// IncidentAggregateItemCollection to service type
// IncidentAggregateItemCollection.
func newIncidentAggregateItemCollection(vres incidentaggregateviews.IncidentAggregateItemCollectionView) IncidentAggregateItemCollection {
	res := make(IncidentAggregateItemCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncidentAggregateItem(n)
	}
	return res
}

// newIncidentAggregateItemCollectionView projects result type
// IncidentAggregateItemCollection to projected type
// IncidentAggregateItemCollectionView using the "default" view.
func newIncidentAggregateItemCollectionView(res IncidentAggregateItemCollection) incidentaggregateviews.IncidentAggregateItemCollectionView {
	vres := make(incidentaggregateviews.IncidentAggregateItemCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentAggregateItemView(n)
	}
	return vres
}

// newIncidentAggregateItem converts projected type IncidentAggregateItem to
// service type IncidentAggregateItem.
func newIncidentAggregateItem(vres *incidentaggregateviews.IncidentAggregateItemView) *IncidentAggregateItem {
	res := &IncidentAggregateItem{
		CreatedAt:          vres.CreatedAt,
		UpdatedAt:          vres.UpdatedAt,
		ResolvedAt:         vres.ResolvedAt,
		ResolutionMessage:  vres.ResolutionMessage,
		State:              vres.State,
		ViolationDataCount: vres.ViolationDataCount,
		ActionFailed:       vres.ActionFailed,
		ActionPending:      vres.ActionPending,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.URL != nil {
		res.URL = *vres.URL
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentaggregateviewsProjectViewToProject(vres.Project)
	}
	if vres.ResolvedBy != nil {
		res.ResolvedBy = transformIncidentaggregateviewsUserViewToUser(vres.ResolvedBy)
	}
	return res
}

// newIncidentAggregateItemView projects result type IncidentAggregateItem to
// projected type IncidentAggregateItemView using the "default" view.
func newIncidentAggregateItemView(res *IncidentAggregateItem) *incidentaggregateviews.IncidentAggregateItemView {
	vres := &incidentaggregateviews.IncidentAggregateItemView{
		ID:                 &res.ID,
		URL:                &res.URL,
		ViolationDataCount: res.ViolationDataCount,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
		ResolvedAt:         res.ResolvedAt,
		ResolutionMessage:  res.ResolutionMessage,
		State:              res.State,
		ActionFailed:       res.ActionFailed,
		ActionPending:      res.ActionPending,
		Kind:               &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentaggregateviewsProjectView(res.Project)
	}
	if res.ResolvedBy != nil {
		vres.ResolvedBy = transformUserToIncidentaggregateviewsUserView(res.ResolvedBy)
	}
	return vres
}

// newIncidentAggregateNonCatalogIndex converts projected type
// IncidentAggregateNonCatalog to service type IncidentAggregateNonCatalog.
func newIncidentAggregateNonCatalogIndex(vres *incidentaggregateviews.IncidentAggregateNonCatalogView) *IncidentAggregateNonCatalog {
	res := &IncidentAggregateNonCatalog{
		Href:        vres.Href,
		UpdatedAt:   vres.UpdatedAt,
		Count:       vres.Count,
		NotModified: vres.NotModified,
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.ActionSummary != nil {
		res.ActionSummary = transformIncidentaggregateviewsActionSummaryViewToActionSummary(vres.ActionSummary)
	}
	if vres.PolicyAggregate != nil {
		res.PolicyAggregate = newPolicyAggregateNonCatalogLink(vres.PolicyAggregate)
	}
	if vres.IncidentSummary != nil {
		res.IncidentSummary = newIncidentSummary(vres.IncidentSummary)
	}
	if vres.Items != nil {
		res.Items = newIncidentAggregateNonCatalogItemCollection(vres.Items)
	}
	return res
}

// newIncidentAggregateNonCatalog converts projected type
// IncidentAggregateNonCatalog to service type IncidentAggregateNonCatalog.
func newIncidentAggregateNonCatalog(vres *incidentaggregateviews.IncidentAggregateNonCatalogView) *IncidentAggregateNonCatalog {
	res := &IncidentAggregateNonCatalog{
		Href:        vres.Href,
		UpdatedAt:   vres.UpdatedAt,
		Count:       vres.Count,
		NotModified: vres.NotModified,
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.ActionSummary != nil {
		res.ActionSummary = transformIncidentaggregateviewsActionSummaryViewToActionSummary(vres.ActionSummary)
	}
	if vres.PolicyAggregate != nil {
		res.PolicyAggregate = newPolicyAggregateNonCatalogLink(vres.PolicyAggregate)
	}
	if vres.IncidentSummary != nil {
		res.IncidentSummary = newIncidentSummary(vres.IncidentSummary)
	}
	if vres.Items != nil {
		res.Items = newIncidentAggregateNonCatalogItemCollection(vres.Items)
	}
	return res
}

// newIncidentAggregateNonCatalogViewIndex projects result type
// IncidentAggregateNonCatalog to projected type
// IncidentAggregateNonCatalogView using the "index" view.
func newIncidentAggregateNonCatalogViewIndex(res *IncidentAggregateNonCatalog) *incidentaggregateviews.IncidentAggregateNonCatalogView {
	vres := &incidentaggregateviews.IncidentAggregateNonCatalogView{
		Href:        res.Href,
		Count:       res.Count,
		UpdatedAt:   res.UpdatedAt,
		Kind:        &res.Kind,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
	}
	if res.ActionSummary != nil {
		vres.ActionSummary = transformActionSummaryToIncidentaggregateviewsActionSummaryView(res.ActionSummary)
	}
	if res.PolicyAggregate != nil {
		vres.PolicyAggregate = newPolicyAggregateNonCatalogViewLink(res.PolicyAggregate)
	}
	if res.IncidentSummary != nil {
		vres.IncidentSummary = newIncidentSummaryView(res.IncidentSummary)
	}
	return vres
}

// newIncidentAggregateNonCatalogView projects result type
// IncidentAggregateNonCatalog to projected type
// IncidentAggregateNonCatalogView using the "default" view.
func newIncidentAggregateNonCatalogView(res *IncidentAggregateNonCatalog) *incidentaggregateviews.IncidentAggregateNonCatalogView {
	vres := &incidentaggregateviews.IncidentAggregateNonCatalogView{
		Href:        res.Href,
		Count:       res.Count,
		UpdatedAt:   res.UpdatedAt,
		Kind:        &res.Kind,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
	}
	if res.IncidentSummary != nil {
		vres.IncidentSummary = transformIncidentSummaryToIncidentaggregateviewsIncidentSummaryView(res.IncidentSummary)
	}
	if res.PolicyAggregate != nil {
		vres.PolicyAggregate = newPolicyAggregateNonCatalogViewLink(res.PolicyAggregate)
	}
	if res.Items != nil {
		vres.Items = newIncidentAggregateNonCatalogItemCollectionView(res.Items)
	}
	if res.ActionSummary != nil {
		vres.ActionSummary = newActionSummaryView(res.ActionSummary)
	}
	return vres
}

// newPolicyAggregateNonCatalog converts projected type
// PolicyAggregateNonCatalog to service type PolicyAggregateNonCatalog.
func newPolicyAggregateNonCatalog(vres *incidentaggregateviews.PolicyAggregateNonCatalogView) *PolicyAggregateNonCatalog {
	res := &PolicyAggregateNonCatalog{
		IncidentAggregateHref: vres.IncidentAggregateHref,
		Count:                 vres.Count,
		ActiveCount:           vres.ActiveCount,
		ErrorCount:            vres.ErrorCount,
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.RunningProjectIds != nil {
		res.RunningProjectIds = make([]uint, len(vres.RunningProjectIds))
		for i, val := range vres.RunningProjectIds {
			res.RunningProjectIds[i] = val
		}
	}
	if vres.Items != nil {
		res.Items = newPolicyAggregateNonCatalogItemCollection(vres.Items)
	}
	return res
}

// newPolicyAggregateNonCatalogIndex converts projected type
// PolicyAggregateNonCatalog to service type PolicyAggregateNonCatalog.
func newPolicyAggregateNonCatalogIndex(vres *incidentaggregateviews.PolicyAggregateNonCatalogView) *PolicyAggregateNonCatalog {
	res := &PolicyAggregateNonCatalog{
		IncidentAggregateHref: vres.IncidentAggregateHref,
		Count:                 vres.Count,
		ActiveCount:           vres.ActiveCount,
		ErrorCount:            vres.ErrorCount,
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.RunningProjectIds != nil {
		res.RunningProjectIds = make([]uint, len(vres.RunningProjectIds))
		for i, val := range vres.RunningProjectIds {
			res.RunningProjectIds[i] = val
		}
	}
	if vres.Items != nil {
		res.Items = newPolicyAggregateNonCatalogItemCollection(vres.Items)
	}
	return res
}

// newPolicyAggregateNonCatalogLink converts projected type
// PolicyAggregateNonCatalog to service type PolicyAggregateNonCatalog.
func newPolicyAggregateNonCatalogLink(vres *incidentaggregateviews.PolicyAggregateNonCatalogView) *PolicyAggregateNonCatalog {
	res := &PolicyAggregateNonCatalog{
		IncidentAggregateHref: vres.IncidentAggregateHref,
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Items != nil {
		res.Items = newPolicyAggregateNonCatalogItemCollection(vres.Items)
	}
	return res
}

// newPolicyAggregateNonCatalogView projects result type
// PolicyAggregateNonCatalog to projected type PolicyAggregateNonCatalogView
// using the "default" view.
func newPolicyAggregateNonCatalogView(res *PolicyAggregateNonCatalog) *incidentaggregateviews.PolicyAggregateNonCatalogView {
	vres := &incidentaggregateviews.PolicyAggregateNonCatalogView{
		Href:                  &res.Href,
		IncidentAggregateHref: res.IncidentAggregateHref,
		Count:                 res.Count,
		ActiveCount:           res.ActiveCount,
		ErrorCount:            res.ErrorCount,
		Kind:                  &res.Kind,
	}
	if res.RunningProjectIds != nil {
		vres.RunningProjectIds = make([]uint, len(res.RunningProjectIds))
		for i, val := range res.RunningProjectIds {
			vres.RunningProjectIds[i] = val
		}
	}
	if res.Items != nil {
		vres.Items = newPolicyAggregateNonCatalogItemCollectionView(res.Items)
	}
	return vres
}

// newPolicyAggregateNonCatalogViewIndex projects result type
// PolicyAggregateNonCatalog to projected type PolicyAggregateNonCatalogView
// using the "index" view.
func newPolicyAggregateNonCatalogViewIndex(res *PolicyAggregateNonCatalog) *incidentaggregateviews.PolicyAggregateNonCatalogView {
	vres := &incidentaggregateviews.PolicyAggregateNonCatalogView{
		Href:                  &res.Href,
		IncidentAggregateHref: res.IncidentAggregateHref,
		Count:                 res.Count,
		ActiveCount:           res.ActiveCount,
		ErrorCount:            res.ErrorCount,
		Kind:                  &res.Kind,
	}
	if res.RunningProjectIds != nil {
		vres.RunningProjectIds = make([]uint, len(res.RunningProjectIds))
		for i, val := range res.RunningProjectIds {
			vres.RunningProjectIds[i] = val
		}
	}
	return vres
}

// newPolicyAggregateNonCatalogViewLink projects result type
// PolicyAggregateNonCatalog to projected type PolicyAggregateNonCatalogView
// using the "link" view.
func newPolicyAggregateNonCatalogViewLink(res *PolicyAggregateNonCatalog) *incidentaggregateviews.PolicyAggregateNonCatalogView {
	vres := &incidentaggregateviews.PolicyAggregateNonCatalogView{
		Href:                  &res.Href,
		IncidentAggregateHref: res.IncidentAggregateHref,
		Kind:                  &res.Kind,
	}
	return vres
}

// newPolicyAggregateNonCatalogItemCollection converts projected type
// PolicyAggregateNonCatalogItemCollection to service type
// PolicyAggregateNonCatalogItemCollection.
func newPolicyAggregateNonCatalogItemCollection(vres incidentaggregateviews.PolicyAggregateNonCatalogItemCollectionView) PolicyAggregateNonCatalogItemCollection {
	res := make(PolicyAggregateNonCatalogItemCollection, len(vres))
	for i, n := range vres {
		res[i] = newPolicyAggregateNonCatalogItem(n)
	}
	return res
}

// newPolicyAggregateNonCatalogItemCollectionView projects result type
// PolicyAggregateNonCatalogItemCollection to projected type
// PolicyAggregateNonCatalogItemCollectionView using the "default" view.
func newPolicyAggregateNonCatalogItemCollectionView(res PolicyAggregateNonCatalogItemCollection) incidentaggregateviews.PolicyAggregateNonCatalogItemCollectionView {
	vres := make(incidentaggregateviews.PolicyAggregateNonCatalogItemCollectionView, len(res))
	for i, n := range res {
		vres[i] = newPolicyAggregateNonCatalogItemView(n)
	}
	return vres
}

// newPolicyAggregateNonCatalogItem converts projected type
// PolicyAggregateNonCatalogItem to service type PolicyAggregateNonCatalogItem.
func newPolicyAggregateNonCatalogItem(vres *incidentaggregateviews.PolicyAggregateNonCatalogItemView) *PolicyAggregateNonCatalogItem {
	res := &PolicyAggregateNonCatalogItem{
		CreatedAt:   vres.CreatedAt,
		UpdatedAt:   vres.UpdatedAt,
		Status:      vres.Status,
		Error:       vres.Error,
		ErroredAt:   vres.ErroredAt,
		Name:        vres.Name,
		Description: vres.Description,
		Severity:    vres.Severity,
		Category:    vres.Category,
		Frequency:   vres.Frequency,
		DryRun:      vres.DryRun,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.URL != nil {
		res.URL = *vres.URL
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentaggregateviewsProjectViewToProject(vres.Project)
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateLink(vres.PolicyTemplate)
	}
	return res
}

// newPolicyAggregateNonCatalogItemView projects result type
// PolicyAggregateNonCatalogItem to projected type
// PolicyAggregateNonCatalogItemView using the "default" view.
func newPolicyAggregateNonCatalogItemView(res *PolicyAggregateNonCatalogItem) *incidentaggregateviews.PolicyAggregateNonCatalogItemView {
	vres := &incidentaggregateviews.PolicyAggregateNonCatalogItemView{
		ID:          &res.ID,
		Name:        res.Name,
		Description: res.Description,
		URL:         &res.URL,
		Status:      res.Status,
		Error:       res.Error,
		ErroredAt:   res.ErroredAt,
		CreatedAt:   res.CreatedAt,
		UpdatedAt:   res.UpdatedAt,
		Severity:    res.Severity,
		Category:    res.Category,
		Frequency:   res.Frequency,
		DryRun:      res.DryRun,
		Kind:        &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentaggregateviewsProjectView(res.Project)
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewLink(res.PolicyTemplate)
	}
	return vres
}

// newPolicyTemplate converts projected type PolicyTemplate to service type
// PolicyTemplate.
func newPolicyTemplate(vres *incidentaggregateviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		ProjectID:        vres.ProjectID,
		RsPtVer:          vres.RsPtVer,
		ShortDescription: vres.ShortDescription,
		DocLink:          vres.DocLink,
		DefaultFrequency: vres.DefaultFrequency,
		Category:         vres.Category,
		CreatedAt:        vres.CreatedAt,
		UpdatedAt:        vres.UpdatedAt,
		Severity:         vres.Severity,
		Tenancy:          vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentaggregateviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	return res
}

// newPolicyTemplateExtended converts projected type PolicyTemplate to service
// type PolicyTemplate.
func newPolicyTemplateExtended(vres *incidentaggregateviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		ProjectID:        vres.ProjectID,
		RsPtVer:          vres.RsPtVer,
		ShortDescription: vres.ShortDescription,
		LongDescription:  vres.LongDescription,
		DocLink:          vres.DocLink,
		DefaultFrequency: vres.DefaultFrequency,
		Category:         vres.Category,
		CreatedAt:        vres.CreatedAt,
		UpdatedAt:        vres.UpdatedAt,
		Severity:         vres.Severity,
		Tenancy:          vres.Tenancy,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentaggregateviewsUserViewToUser(vres.UpdatedBy)
	}
	if vres.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(vres.Permissions))
		for key, val := range vres.Permissions {
			tk := key
			res.Permissions[tk] = transformIncidentaggregateviewsPermissionViewToPermission(val)
		}
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentaggregateviewsParameterViewToParameter(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]*Credentials, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			res.Credentials[tk] = transformIncidentaggregateviewsCredentialsViewToCredentials(val)
		}
	}
	return res
}

// newPolicyTemplateSource converts projected type PolicyTemplate to service
// type PolicyTemplate.
func newPolicyTemplateSource(vres *incidentaggregateviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		Filename: vres.Filename,
		Source:   vres.Source,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	return res
}

// newPolicyTemplateLink converts projected type PolicyTemplate to service type
// PolicyTemplate.
func newPolicyTemplateLink(vres *incidentaggregateviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		UpdatedAt: vres.UpdatedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentaggregateviewsUserViewToUser(vres.UpdatedBy)
	}
	return res
}

// newPolicyTemplateView projects result type PolicyTemplate to projected type
// PolicyTemplateView using the "default" view.
func newPolicyTemplateView(res *PolicyTemplate) *incidentaggregateviews.PolicyTemplateView {
	vres := &incidentaggregateviews.PolicyTemplateView{
		ID:               &res.ID,
		Name:             &res.Name,
		ProjectID:        res.ProjectID,
		RsPtVer:          res.RsPtVer,
		ShortDescription: res.ShortDescription,
		DocLink:          res.DocLink,
		DefaultFrequency: res.DefaultFrequency,
		Href:             &res.Href,
		Fingerprint:      &res.Fingerprint,
		Category:         res.Category,
		CreatedAt:        res.CreatedAt,
		UpdatedAt:        res.UpdatedAt,
		Severity:         res.Severity,
		Tenancy:          res.Tenancy,
		Kind:             &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentaggregateviewsUserView(res.UpdatedBy)
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	return vres
}

// newPolicyTemplateViewExtended projects result type PolicyTemplate to
// projected type PolicyTemplateView using the "extended" view.
func newPolicyTemplateViewExtended(res *PolicyTemplate) *incidentaggregateviews.PolicyTemplateView {
	vres := &incidentaggregateviews.PolicyTemplateView{
		ID:               &res.ID,
		Name:             &res.Name,
		ProjectID:        res.ProjectID,
		RsPtVer:          res.RsPtVer,
		ShortDescription: res.ShortDescription,
		LongDescription:  res.LongDescription,
		DocLink:          res.DocLink,
		DefaultFrequency: res.DefaultFrequency,
		Href:             &res.Href,
		Fingerprint:      &res.Fingerprint,
		Category:         res.Category,
		CreatedAt:        res.CreatedAt,
		UpdatedAt:        res.UpdatedAt,
		Severity:         res.Severity,
		Tenancy:          res.Tenancy,
		Kind:             &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentaggregateviewsUserView(res.UpdatedBy)
	}
	if res.Permissions != nil {
		vres.Permissions = make(map[string]*incidentaggregateviews.PermissionView, len(res.Permissions))
		for key, val := range res.Permissions {
			tk := key
			vres.Permissions[tk] = transformPermissionToIncidentaggregateviewsPermissionView(val)
		}
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*incidentaggregateviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			vres.Parameters[tk] = transformParameterToIncidentaggregateviewsParameterView(val)
		}
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]*incidentaggregateviews.CredentialsView, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			vres.Credentials[tk] = transformCredentialsToIncidentaggregateviewsCredentialsView(val)
		}
	}
	return vres
}

// newPolicyTemplateViewSource projects result type PolicyTemplate to projected
// type PolicyTemplateView using the "source" view.
func newPolicyTemplateViewSource(res *PolicyTemplate) *incidentaggregateviews.PolicyTemplateView {
	vres := &incidentaggregateviews.PolicyTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Filename:    res.Filename,
		Source:      res.Source,
		Fingerprint: &res.Fingerprint,
		Kind:        &res.Kind,
	}
	return vres
}

// newPolicyTemplateViewLink projects result type PolicyTemplate to projected
// type PolicyTemplateView using the "link" view.
func newPolicyTemplateViewLink(res *PolicyTemplate) *incidentaggregateviews.PolicyTemplateView {
	vres := &incidentaggregateviews.PolicyTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Fingerprint: &res.Fingerprint,
		UpdatedAt:   res.UpdatedAt,
		Kind:        &res.Kind,
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = transformUserToIncidentaggregateviewsUserView(res.UpdatedBy)
	}
	return vres
}

// newIncidentAggregateNonCatalogItemCollection converts projected type
// IncidentAggregateNonCatalogItemCollection to service type
// IncidentAggregateNonCatalogItemCollection.
func newIncidentAggregateNonCatalogItemCollection(vres incidentaggregateviews.IncidentAggregateNonCatalogItemCollectionView) IncidentAggregateNonCatalogItemCollection {
	res := make(IncidentAggregateNonCatalogItemCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncidentAggregateNonCatalogItem(n)
	}
	return res
}

// newIncidentAggregateNonCatalogItemCollectionView projects result type
// IncidentAggregateNonCatalogItemCollection to projected type
// IncidentAggregateNonCatalogItemCollectionView using the "default" view.
func newIncidentAggregateNonCatalogItemCollectionView(res IncidentAggregateNonCatalogItemCollection) incidentaggregateviews.IncidentAggregateNonCatalogItemCollectionView {
	vres := make(incidentaggregateviews.IncidentAggregateNonCatalogItemCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentAggregateNonCatalogItemView(n)
	}
	return vres
}

// newIncidentAggregateNonCatalogItem converts projected type
// IncidentAggregateNonCatalogItem to service type
// IncidentAggregateNonCatalogItem.
func newIncidentAggregateNonCatalogItem(vres *incidentaggregateviews.IncidentAggregateNonCatalogItemView) *IncidentAggregateNonCatalogItem {
	res := &IncidentAggregateNonCatalogItem{
		CreatedAt:          vres.CreatedAt,
		UpdatedAt:          vres.UpdatedAt,
		ResolvedAt:         vres.ResolvedAt,
		ResolutionMessage:  vres.ResolutionMessage,
		State:              vres.State,
		ViolationDataCount: vres.ViolationDataCount,
		ActionFailed:       vres.ActionFailed,
		ActionPending:      vres.ActionPending,
		Severity:           vres.Severity,
		Category:           vres.Category,
		DryRun:             vres.DryRun,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.URL != nil {
		res.URL = *vres.URL
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentaggregateviewsProjectViewToProject(vres.Project)
	}
	if vres.ResolvedBy != nil {
		res.ResolvedBy = transformIncidentaggregateviewsUserViewToUser(vres.ResolvedBy)
	}
	if vres.AppliedPolicy != nil {
		res.AppliedPolicy = newAppliedPolicyLink(vres.AppliedPolicy)
	}
	return res
}

// newIncidentAggregateNonCatalogItemView projects result type
// IncidentAggregateNonCatalogItem to projected type
// IncidentAggregateNonCatalogItemView using the "default" view.
func newIncidentAggregateNonCatalogItemView(res *IncidentAggregateNonCatalogItem) *incidentaggregateviews.IncidentAggregateNonCatalogItemView {
	vres := &incidentaggregateviews.IncidentAggregateNonCatalogItemView{
		ID:                 &res.ID,
		URL:                &res.URL,
		ViolationDataCount: res.ViolationDataCount,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
		ResolvedAt:         res.ResolvedAt,
		ResolutionMessage:  res.ResolutionMessage,
		State:              res.State,
		ActionFailed:       res.ActionFailed,
		ActionPending:      res.ActionPending,
		Severity:           res.Severity,
		Category:           res.Category,
		DryRun:             res.DryRun,
		Kind:               &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentaggregateviewsProjectView(res.Project)
	}
	if res.ResolvedBy != nil {
		vres.ResolvedBy = transformUserToIncidentaggregateviewsUserView(res.ResolvedBy)
	}
	if res.AppliedPolicy != nil {
		vres.AppliedPolicy = newAppliedPolicyViewLink(res.AppliedPolicy)
	}
	return vres
}

// newAppliedPolicy converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicy(vres *incidentaggregateviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		PolicyAggregateID:   vres.PolicyAggregateID,
		IncidentAggregateID: vres.IncidentAggregateID,
		Description:         vres.Description,
		DocLink:             vres.DocLink,
		CreatedAt:           vres.CreatedAt,
		UpdatedAt:           vres.UpdatedAt,
		Severity:            vres.Severity,
		Category:            vres.Category,
		Frequency:           vres.Frequency,
		DryRun:              vres.DryRun,
		SkipApprovals:       vres.SkipApprovals,
		Status:              vres.Status,
		Error:               vres.Error,
		ErroredAt:           vres.ErroredAt,
		Scope:               vres.Scope,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentaggregateviewsProjectViewToProject(vres.Project)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = transformIncidentaggregateviewsPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = transformIncidentaggregateviewsConfigurationOptionViewToConfigurationOption(val)
		}
	}
	if vres.Credentials != nil {
		res.Credentials = make(map[string]string, len(vres.Credentials))
		for key, val := range vres.Credentials {
			tk := key
			tv := val
			res.Credentials[tk] = tv
		}
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateLink(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicySource converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicySource(vres *incidentaggregateviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		PolicyAggregateID:   vres.PolicyAggregateID,
		IncidentAggregateID: vres.IncidentAggregateID,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = transformIncidentaggregateviewsProjectViewToProject(vres.Project)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = transformIncidentaggregateviewsPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateSource(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicyLink converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicyLink(vres *incidentaggregateviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		PolicyAggregateID:   vres.PolicyAggregateID,
		IncidentAggregateID: vres.IncidentAggregateID,
		CreatedAt:           vres.CreatedAt,
		Frequency:           vres.Frequency,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = transformIncidentaggregateviewsPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(vres.CreatedBy)
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateLink(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicyView projects result type AppliedPolicy to projected type
// AppliedPolicyView using the "default" view.
func newAppliedPolicyView(res *AppliedPolicy) *incidentaggregateviews.AppliedPolicyView {
	vres := &incidentaggregateviews.AppliedPolicyView{
		ID:                  &res.ID,
		PolicyAggregateID:   res.PolicyAggregateID,
		IncidentAggregateID: res.IncidentAggregateID,
		Name:                &res.Name,
		Href:                &res.Href,
		Description:         res.Description,
		DocLink:             res.DocLink,
		CreatedAt:           res.CreatedAt,
		UpdatedAt:           res.UpdatedAt,
		Severity:            res.Severity,
		Category:            res.Category,
		Frequency:           res.Frequency,
		DryRun:              res.DryRun,
		SkipApprovals:       res.SkipApprovals,
		Status:              res.Status,
		Error:               res.Error,
		ErroredAt:           res.ErroredAt,
		Scope:               res.Scope,
		Kind:                &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentaggregateviewsProjectView(res.Project)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = transformPublishedTemplateToIncidentaggregateviewsPublishedTemplateView(res.PublishedTemplate)
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.Options != nil {
		vres.Options = make([]*incidentaggregateviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = transformConfigurationOptionToIncidentaggregateviewsConfigurationOptionView(val)
		}
	}
	if res.Credentials != nil {
		vres.Credentials = make(map[string]string, len(res.Credentials))
		for key, val := range res.Credentials {
			tk := key
			tv := val
			vres.Credentials[tk] = tv
		}
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewLink(res.PolicyTemplate)
	}
	return vres
}

// newAppliedPolicyViewSource projects result type AppliedPolicy to projected
// type AppliedPolicyView using the "source" view.
func newAppliedPolicyViewSource(res *AppliedPolicy) *incidentaggregateviews.AppliedPolicyView {
	vres := &incidentaggregateviews.AppliedPolicyView{
		ID:                  &res.ID,
		PolicyAggregateID:   res.PolicyAggregateID,
		IncidentAggregateID: res.IncidentAggregateID,
		Name:                &res.Name,
		Href:                &res.Href,
		Kind:                &res.Kind,
	}
	if res.Project != nil {
		vres.Project = transformProjectToIncidentaggregateviewsProjectView(res.Project)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = transformPublishedTemplateToIncidentaggregateviewsPublishedTemplateView(res.PublishedTemplate)
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewSource(res.PolicyTemplate)
	}
	return vres
}

// newAppliedPolicyViewLink projects result type AppliedPolicy to projected
// type AppliedPolicyView using the "link" view.
func newAppliedPolicyViewLink(res *AppliedPolicy) *incidentaggregateviews.AppliedPolicyView {
	vres := &incidentaggregateviews.AppliedPolicyView{
		ID:                  &res.ID,
		PolicyAggregateID:   res.PolicyAggregateID,
		IncidentAggregateID: res.IncidentAggregateID,
		Name:                &res.Name,
		Href:                &res.Href,
		CreatedAt:           res.CreatedAt,
		Frequency:           res.Frequency,
		Kind:                &res.Kind,
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = transformPublishedTemplateToIncidentaggregateviewsPublishedTemplateView(res.PublishedTemplate)
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = transformUserToIncidentaggregateviewsUserView(res.CreatedBy)
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewLink(res.PolicyTemplate)
	}
	return vres
}

// newIncidentAggregateList converts projected type IncidentAggregateList to
// service type IncidentAggregateList.
func newIncidentAggregateList(vres *incidentaggregateviews.IncidentAggregateListView) *IncidentAggregateList {
	res := &IncidentAggregateList{
		Count:       vres.Count,
		NotModified: vres.NotModified,
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Items != nil {
		res.Items = newIncidentAggregateCollectionIndex(vres.Items)
	}
	return res
}

// newIncidentAggregateListView projects result type IncidentAggregateList to
// projected type IncidentAggregateListView using the "default" view.
func newIncidentAggregateListView(res *IncidentAggregateList) *incidentaggregateviews.IncidentAggregateListView {
	vres := &incidentaggregateviews.IncidentAggregateListView{
		Count:       res.Count,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
		Kind:        &res.Kind,
	}
	if res.Items != nil {
		vres.Items = newIncidentAggregateCollectionViewIndex(res.Items)
	}
	return vres
}

// newIncidentAggregateCollectionIndex converts projected type
// IncidentAggregateCollection to service type IncidentAggregateCollection.
func newIncidentAggregateCollectionIndex(vres incidentaggregateviews.IncidentAggregateCollectionView) IncidentAggregateCollection {
	res := make(IncidentAggregateCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncidentAggregateIndex(n)
	}
	return res
}

// newIncidentAggregateCollection converts projected type
// IncidentAggregateCollection to service type IncidentAggregateCollection.
func newIncidentAggregateCollection(vres incidentaggregateviews.IncidentAggregateCollectionView) IncidentAggregateCollection {
	res := make(IncidentAggregateCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncidentAggregate(n)
	}
	return res
}

// newIncidentAggregateCollectionSource converts projected type
// IncidentAggregateCollection to service type IncidentAggregateCollection.
func newIncidentAggregateCollectionSource(vres incidentaggregateviews.IncidentAggregateCollectionView) IncidentAggregateCollection {
	res := make(IncidentAggregateCollection, len(vres))
	for i, n := range vres {
		res[i] = newIncidentAggregateSource(n)
	}
	return res
}

// newIncidentAggregateCollectionViewIndex projects result type
// IncidentAggregateCollection to projected type
// IncidentAggregateCollectionView using the "index" view.
func newIncidentAggregateCollectionViewIndex(res IncidentAggregateCollection) incidentaggregateviews.IncidentAggregateCollectionView {
	vres := make(incidentaggregateviews.IncidentAggregateCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentAggregateViewIndex(n)
	}
	return vres
}

// newIncidentAggregateCollectionView projects result type
// IncidentAggregateCollection to projected type
// IncidentAggregateCollectionView using the "default" view.
func newIncidentAggregateCollectionView(res IncidentAggregateCollection) incidentaggregateviews.IncidentAggregateCollectionView {
	vres := make(incidentaggregateviews.IncidentAggregateCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentAggregateView(n)
	}
	return vres
}

// newIncidentAggregateCollectionViewSource projects result type
// IncidentAggregateCollection to projected type
// IncidentAggregateCollectionView using the "source" view.
func newIncidentAggregateCollectionViewSource(res IncidentAggregateCollection) incidentaggregateviews.IncidentAggregateCollectionView {
	vres := make(incidentaggregateviews.IncidentAggregateCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIncidentAggregateViewSource(n)
	}
	return vres
}

// transformIncidentaggregateviewsOrgViewToOrg builds a value of type *Org from
// a value of type *incidentaggregateviews.OrgView.
func transformIncidentaggregateviewsOrgViewToOrg(v *incidentaggregateviews.OrgView) *Org {
	if v == nil {
		return nil
	}
	res := &Org{
		ID:   *v.ID,
		Name: *v.Name,
	}

	return res
}

// transformIncidentaggregateviewsActionSummaryViewToActionSummary builds a
// value of type *ActionSummary from a value of type
// *incidentaggregateviews.ActionSummaryView.
func transformIncidentaggregateviewsActionSummaryViewToActionSummary(v *incidentaggregateviews.ActionSummaryView) *ActionSummary {
	if v == nil {
		return nil
	}
	res := &ActionSummary{
		PendingCount: *v.PendingCount,
		FailedCount:  *v.FailedCount,
	}

	return res
}

// transformOrgToIncidentaggregateviewsOrgView builds a value of type
// *incidentaggregateviews.OrgView from a value of type *Org.
func transformOrgToIncidentaggregateviewsOrgView(v *Org) *incidentaggregateviews.OrgView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.OrgView{
		ID:   &v.ID,
		Name: &v.Name,
	}

	return res
}

// transformActionSummaryToIncidentaggregateviewsActionSummaryView builds a
// value of type *incidentaggregateviews.ActionSummaryView from a value of type
// *ActionSummary.
func transformActionSummaryToIncidentaggregateviewsActionSummaryView(v *ActionSummary) *incidentaggregateviews.ActionSummaryView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.ActionSummaryView{
		PendingCount: &v.PendingCount,
		FailedCount:  &v.FailedCount,
	}

	return res
}

// transformIncidentSummaryToIncidentaggregateviewsIncidentSummaryView builds a
// value of type *incidentaggregateviews.IncidentSummaryView from a value of
// type *IncidentSummary.
func transformIncidentSummaryToIncidentaggregateviewsIncidentSummaryView(v *IncidentSummary) *incidentaggregateviews.IncidentSummaryView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.IncidentSummaryView{
		IncidentCount:      &v.IncidentCount,
		ViolationDataCount: &v.ViolationDataCount,
		ResolvedCount:      &v.ResolvedCount,
		TriggeredCount:     &v.TriggeredCount,
	}

	return res
}

// transformIncidentaggregateviewsUserViewToUser builds a value of type *User
// from a value of type *incidentaggregateviews.UserView.
func transformIncidentaggregateviewsUserViewToUser(v *incidentaggregateviews.UserView) *User {
	if v == nil {
		return nil
	}
	res := &User{
		ID:    *v.ID,
		Email: *v.Email,
		Name:  *v.Name,
	}

	return res
}

// transformIncidentaggregateviewsConfigurationOptionViewToConfigurationOption
// builds a value of type *ConfigurationOption from a value of type
// *incidentaggregateviews.ConfigurationOptionView.
func transformIncidentaggregateviewsConfigurationOptionViewToConfigurationOption(v *incidentaggregateviews.ConfigurationOptionView) *ConfigurationOption {
	if v == nil {
		return nil
	}
	res := &ConfigurationOption{
		Name:  *v.Name,
		Label: *v.Label,
		Type:  *v.Type,
		Value: v.Value,
	}
	if v.NoEcho != nil {
		res.NoEcho = *v.NoEcho
	}
	if v.NoEcho == nil {
		res.NoEcho = false
	}

	return res
}

// transformUserToIncidentaggregateviewsUserView builds a value of type
// *incidentaggregateviews.UserView from a value of type *User.
func transformUserToIncidentaggregateviewsUserView(v *User) *incidentaggregateviews.UserView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.UserView{
		ID:    &v.ID,
		Email: &v.Email,
		Name:  &v.Name,
	}

	return res
}

// transformConfigurationOptionToIncidentaggregateviewsConfigurationOptionView
// builds a value of type *incidentaggregateviews.ConfigurationOptionView from
// a value of type *ConfigurationOption.
func transformConfigurationOptionToIncidentaggregateviewsConfigurationOptionView(v *ConfigurationOption) *incidentaggregateviews.ConfigurationOptionView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.ConfigurationOptionView{
		Name:   &v.Name,
		Label:  &v.Label,
		Type:   &v.Type,
		Value:  v.Value,
		NoEcho: &v.NoEcho,
	}

	return res
}

// transformIncidentaggregateviewsPermissionViewToPermission builds a value of
// type *Permission from a value of type *incidentaggregateviews.PermissionView.
func transformIncidentaggregateviewsPermissionViewToPermission(v *incidentaggregateviews.PermissionView) *Permission {
	if v == nil {
		return nil
	}
	res := &Permission{
		Name:  *v.Name,
		Label: v.Label,
	}
	if v.Resources != nil {
		res.Resources = make([]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = val
		}
	}
	if v.Actions != nil {
		res.Actions = make([]string, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = val
		}
	}

	return res
}

// transformIncidentaggregateviewsParameterViewToParameter builds a value of
// type *Parameter from a value of type *incidentaggregateviews.ParameterView.
func transformIncidentaggregateviewsParameterViewToParameter(v *incidentaggregateviews.ParameterView) *Parameter {
	if v == nil {
		return nil
	}
	res := &Parameter{
		Name:                  *v.Name,
		Type:                  *v.Type,
		Label:                 *v.Label,
		Index:                 *v.Index,
		Category:              v.Category,
		Description:           v.Description,
		Default:               v.Default,
		MinLength:             v.MinLength,
		MaxLength:             v.MaxLength,
		MinValue:              v.MinValue,
		MaxValue:              v.MaxValue,
		ConstraintDescription: v.ConstraintDescription,
	}
	if v.NoEcho != nil {
		res.NoEcho = *v.NoEcho
	}
	if v.NoEcho == nil {
		res.NoEcho = false
	}
	if v.AllowedValues != nil {
		res.AllowedValues = make([]interface{}, len(v.AllowedValues))
		for i, val := range v.AllowedValues {
			res.AllowedValues[i] = val
		}
	}
	if v.AllowedPattern != nil {
		res.AllowedPattern = transformIncidentaggregateviewsRegexpViewToRegexp(v.AllowedPattern)
	}

	return res
}

// transformIncidentaggregateviewsRegexpViewToRegexp builds a value of type
// *Regexp from a value of type *incidentaggregateviews.RegexpView.
func transformIncidentaggregateviewsRegexpViewToRegexp(v *incidentaggregateviews.RegexpView) *Regexp {
	if v == nil {
		return nil
	}
	res := &Regexp{
		Pattern: *v.Pattern,
		Options: v.Options,
	}

	return res
}

// transformIncidentaggregateviewsCredentialsViewToCredentials builds a value
// of type *Credentials from a value of type
// *incidentaggregateviews.CredentialsView.
func transformIncidentaggregateviewsCredentialsViewToCredentials(v *incidentaggregateviews.CredentialsView) *Credentials {
	if v == nil {
		return nil
	}
	res := &Credentials{
		Name:        *v.Name,
		Label:       *v.Label,
		Description: v.Description,
	}
	if v.Schemes != nil {
		res.Schemes = make([]string, len(v.Schemes))
		for i, val := range v.Schemes {
			res.Schemes[i] = val
		}
	}
	if v.Tags != nil {
		res.Tags = make([]*CredentialsTag, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = transformIncidentaggregateviewsCredentialsTagViewToCredentialsTag(val)
		}
	}

	return res
}

// transformIncidentaggregateviewsCredentialsTagViewToCredentialsTag builds a
// value of type *CredentialsTag from a value of type
// *incidentaggregateviews.CredentialsTagView.
func transformIncidentaggregateviewsCredentialsTagViewToCredentialsTag(v *incidentaggregateviews.CredentialsTagView) *CredentialsTag {
	if v == nil {
		return nil
	}
	res := &CredentialsTag{
		Key:   *v.Key,
		Value: *v.Value,
	}

	return res
}

// transformPermissionToIncidentaggregateviewsPermissionView builds a value of
// type *incidentaggregateviews.PermissionView from a value of type *Permission.
func transformPermissionToIncidentaggregateviewsPermissionView(v *Permission) *incidentaggregateviews.PermissionView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.PermissionView{
		Name:  &v.Name,
		Label: v.Label,
	}
	if v.Resources != nil {
		res.Resources = make([]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = val
		}
	}
	if v.Actions != nil {
		res.Actions = make([]string, len(v.Actions))
		for i, val := range v.Actions {
			res.Actions[i] = val
		}
	}

	return res
}

// transformParameterToIncidentaggregateviewsParameterView builds a value of
// type *incidentaggregateviews.ParameterView from a value of type *Parameter.
func transformParameterToIncidentaggregateviewsParameterView(v *Parameter) *incidentaggregateviews.ParameterView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.ParameterView{
		Name:                  &v.Name,
		Type:                  &v.Type,
		Label:                 &v.Label,
		Index:                 &v.Index,
		Category:              v.Category,
		Description:           v.Description,
		Default:               v.Default,
		NoEcho:                &v.NoEcho,
		MinLength:             v.MinLength,
		MaxLength:             v.MaxLength,
		MinValue:              v.MinValue,
		MaxValue:              v.MaxValue,
		ConstraintDescription: v.ConstraintDescription,
	}
	if v.AllowedValues != nil {
		res.AllowedValues = make([]interface{}, len(v.AllowedValues))
		for i, val := range v.AllowedValues {
			res.AllowedValues[i] = val
		}
	}
	if v.AllowedPattern != nil {
		res.AllowedPattern = transformRegexpToIncidentaggregateviewsRegexpView(v.AllowedPattern)
	}

	return res
}

// transformRegexpToIncidentaggregateviewsRegexpView builds a value of type
// *incidentaggregateviews.RegexpView from a value of type *Regexp.
func transformRegexpToIncidentaggregateviewsRegexpView(v *Regexp) *incidentaggregateviews.RegexpView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.RegexpView{
		Pattern: &v.Pattern,
		Options: v.Options,
	}

	return res
}

// transformCredentialsToIncidentaggregateviewsCredentialsView builds a value
// of type *incidentaggregateviews.CredentialsView from a value of type
// *Credentials.
func transformCredentialsToIncidentaggregateviewsCredentialsView(v *Credentials) *incidentaggregateviews.CredentialsView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.CredentialsView{
		Name:        &v.Name,
		Label:       &v.Label,
		Description: v.Description,
	}
	if v.Schemes != nil {
		res.Schemes = make([]string, len(v.Schemes))
		for i, val := range v.Schemes {
			res.Schemes[i] = val
		}
	}
	if v.Tags != nil {
		res.Tags = make([]*incidentaggregateviews.CredentialsTagView, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = transformCredentialsTagToIncidentaggregateviewsCredentialsTagView(val)
		}
	}

	return res
}

// transformCredentialsTagToIncidentaggregateviewsCredentialsTagView builds a
// value of type *incidentaggregateviews.CredentialsTagView from a value of
// type *CredentialsTag.
func transformCredentialsTagToIncidentaggregateviewsCredentialsTagView(v *CredentialsTag) *incidentaggregateviews.CredentialsTagView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.CredentialsTagView{
		Key:   &v.Key,
		Value: &v.Value,
	}

	return res
}

// transformIncidentaggregateviewsProjectViewToProject builds a value of type
// *Project from a value of type *incidentaggregateviews.ProjectView.
func transformIncidentaggregateviewsProjectViewToProject(v *incidentaggregateviews.ProjectView) *Project {
	if v == nil {
		return nil
	}
	res := &Project{
		ID:      *v.ID,
		Name:    *v.Name,
		OrgID:   *v.OrgID,
		OrgName: *v.OrgName,
	}

	return res
}

// transformProjectToIncidentaggregateviewsProjectView builds a value of type
// *incidentaggregateviews.ProjectView from a value of type *Project.
func transformProjectToIncidentaggregateviewsProjectView(v *Project) *incidentaggregateviews.ProjectView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.ProjectView{
		ID:      &v.ID,
		Name:    &v.Name,
		OrgID:   &v.OrgID,
		OrgName: &v.OrgName,
	}

	return res
}

// transformIncidentaggregateviewsPublishedTemplateViewToPublishedTemplate
// builds a value of type *PublishedTemplate from a value of type
// *incidentaggregateviews.PublishedTemplateView.
func transformIncidentaggregateviewsPublishedTemplateViewToPublishedTemplate(v *incidentaggregateviews.PublishedTemplateView) *PublishedTemplate {
	if v == nil {
		return nil
	}
	res := &PublishedTemplate{
		ID:                        *v.ID,
		Name:                      *v.Name,
		OrgID:                     v.OrgID,
		ProjectID:                 v.ProjectID,
		PolicyTemplateID:          v.PolicyTemplateID,
		PolicyTemplateURL:         v.PolicyTemplateURL,
		PolicyTemplateFingerprint: v.PolicyTemplateFingerprint,
		RsPtVer:                   v.RsPtVer,
		ShortDescription:          v.ShortDescription,
		LongDescription:           v.LongDescription,
		DocLink:                   v.DocLink,
		DefaultFrequency:          v.DefaultFrequency,
		Href:                      *v.Href,
		Filename:                  v.Filename,
		Source:                    v.Source,
		Fingerprint:               *v.Fingerprint,
		Category:                  v.Category,
		CreatedAt:                 v.CreatedAt,
		UpdatedAt:                 v.UpdatedAt,
		Severity:                  v.Severity,
		BuiltIn:                   v.BuiltIn,
		Hidden:                    v.Hidden,
		HiddenAt:                  v.HiddenAt,
		Tenancy:                   v.Tenancy,
		Kind:                      *v.Kind,
	}
	if v.Info != nil {
		res.Info = make(map[string]string, len(v.Info))
		for key, val := range v.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if v.CreatedBy != nil {
		res.CreatedBy = transformIncidentaggregateviewsUserViewToUser(v.CreatedBy)
	}
	if v.UpdatedBy != nil {
		res.UpdatedBy = transformIncidentaggregateviewsUserViewToUser(v.UpdatedBy)
	}
	if v.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(v.Permissions))
		for key, val := range v.Permissions {
			tk := key
			res.Permissions[tk] = transformIncidentaggregateviewsPermissionViewToPermission(val)
		}
	}
	if v.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(v.RequiredRoles))
		for i, val := range v.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformIncidentaggregateviewsParameterViewToParameter(val)
		}
	}
	if v.HiddenBy != nil {
		res.HiddenBy = transformIncidentaggregateviewsUserViewToUser(v.HiddenBy)
	}
	if v.Credentials != nil {
		res.Credentials = make(map[string]*Credentials, len(v.Credentials))
		for key, val := range v.Credentials {
			tk := key
			res.Credentials[tk] = transformIncidentaggregateviewsCredentialsViewToCredentials(val)
		}
	}

	return res
}

// transformPublishedTemplateToIncidentaggregateviewsPublishedTemplateView
// builds a value of type *incidentaggregateviews.PublishedTemplateView from a
// value of type *PublishedTemplate.
func transformPublishedTemplateToIncidentaggregateviewsPublishedTemplateView(v *PublishedTemplate) *incidentaggregateviews.PublishedTemplateView {
	if v == nil {
		return nil
	}
	res := &incidentaggregateviews.PublishedTemplateView{
		ID:                        &v.ID,
		Name:                      &v.Name,
		OrgID:                     v.OrgID,
		ProjectID:                 v.ProjectID,
		PolicyTemplateID:          v.PolicyTemplateID,
		PolicyTemplateURL:         v.PolicyTemplateURL,
		PolicyTemplateFingerprint: v.PolicyTemplateFingerprint,
		RsPtVer:                   v.RsPtVer,
		ShortDescription:          v.ShortDescription,
		LongDescription:           v.LongDescription,
		DocLink:                   v.DocLink,
		DefaultFrequency:          v.DefaultFrequency,
		Href:                      &v.Href,
		Filename:                  v.Filename,
		Source:                    v.Source,
		Fingerprint:               &v.Fingerprint,
		Category:                  v.Category,
		CreatedAt:                 v.CreatedAt,
		UpdatedAt:                 v.UpdatedAt,
		Severity:                  v.Severity,
		BuiltIn:                   v.BuiltIn,
		Hidden:                    v.Hidden,
		HiddenAt:                  v.HiddenAt,
		Tenancy:                   v.Tenancy,
		Kind:                      &v.Kind,
	}
	if v.Info != nil {
		res.Info = make(map[string]string, len(v.Info))
		for key, val := range v.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if v.CreatedBy != nil {
		res.CreatedBy = transformUserToIncidentaggregateviewsUserView(v.CreatedBy)
	}
	if v.UpdatedBy != nil {
		res.UpdatedBy = transformUserToIncidentaggregateviewsUserView(v.UpdatedBy)
	}
	if v.Permissions != nil {
		res.Permissions = make(map[string]*incidentaggregateviews.PermissionView, len(v.Permissions))
		for key, val := range v.Permissions {
			tk := key
			res.Permissions[tk] = transformPermissionToIncidentaggregateviewsPermissionView(val)
		}
	}
	if v.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(v.RequiredRoles))
		for i, val := range v.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*incidentaggregateviews.ParameterView, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			res.Parameters[tk] = transformParameterToIncidentaggregateviewsParameterView(val)
		}
	}
	if v.HiddenBy != nil {
		res.HiddenBy = transformUserToIncidentaggregateviewsUserView(v.HiddenBy)
	}
	if v.Credentials != nil {
		res.Credentials = make(map[string]*incidentaggregateviews.CredentialsView, len(v.Credentials))
		for key, val := range v.Credentials {
			tk := key
			res.Credentials[tk] = transformCredentialsToIncidentaggregateviewsCredentialsView(val)
		}
	}

	return res
}
